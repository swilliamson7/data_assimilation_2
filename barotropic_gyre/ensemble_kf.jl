# We need a version of the integration function that runs a single timestep and 
# takes as input the current prognostic fields. This function will then be
# passed to Enzyme for computing the Jacobian, which can subsequently be used
# in the Kalman filter. We're giving as input uveta, which will be a block
# vector of the fields u, v, and eta in that order. The restructuring of the
# arrays will be as columns stacked on top of eachother, e.g. the first column becomes
# the first bit of the vector, the second column the second bit, and so on.

using Parameters
# Enzyme.API.looseTypeAnalysis!(true)

"""
This function will run the ensemble Kalman filter. It needs to be given:
    model - this will contain all the information needed for the ensemble run
    param_guess - the guess at what the initial condition is
"""
# function run_ensemble_kf(model, param_guess; udata=false,vdata=false,etadata=false)

#     N = model.N
#     data = model.data
#     data_steps = model.data_steps
#     data_spots = model.data_spots
#     sigma_initcond = model.sigma_initcond
#     sigma_data = model.sigma_data
#     j = model.j

#     # save the average u, v, and eta values from the data assimilation
#     ekf_avgu = []
#     ekf_avgv = []
#     ekf_avgeta = []

#     uic = model.S.parameters.T.(zeros(model.S.grid.nux,model.S.grid.nuy))
#     vic = model.S.parameters.T.(zeros(model.S.grid.nvx,model.S.grid.nvy))
#     etaic = model.S.parameters.T.(zeros(model.S.grid.nx,model.S.grid.ny))
#     current = 1
#     for m in (uic, vic, etaic)
#         sz = prod(size(m))
#         m .= reshape(param_guess[current:(current + sz - 1)], size(m)...)
#         current += sz
#     end

#     Π = (I - (1 / N)*(ones(N) * ones(N)')) / sqrt(N - 1)
#     W = zeros(N,N)
#     T = zeros(N,N)

#     S_for_values = deepcopy(model.S)

#     nu = S_for_values.grid.nu
#     nv = S_for_values.grid.nv
#     nT = S_for_values.grid.nT

#     S = zeros(length(data_spots), N)
#     U = zeros(length(data_spots), N)

#     # Generate the initial model realization ensemble,
#     # generated by slightly perturbing the initial condition N times.
#     # Output will be stored in the matrix Z, and all model structs will be
#     # stored in S_all
#     # We assume that Z is the total state vector in size, so 48896 is the
#     # whole length of u + v + eta as a column vector
#     Z = zeros(model.S.grid.nu + model.S.grid.nv + model.S.grid.nT, N)
#     S_all = []

#     bred_vectors = compute_bred_vectors(N,sigma_initcond,uic,vic,etaic,model.S.parameters)

#     for n = 1:N

#         S_kf = deepcopy(model.S)

#         #only keeping this so I have an sst field without a halo for later step
#         P_kf = ShallowWaters.PrognosticVars{S_kf.parameters.Tprog}(ShallowWaters.remove_halo(S_kf.Prog.u,
#             S_kf.Prog.v,
#             S_kf.Prog.η,
#             S_kf.Prog.sst,
#             S_kf)...
#         )

#         # using bred vectors to perturb initial condition in each ensemble member
#         uic = uic + reshape(bred_vectors[n][1:model.S.grid.nu], model.S.grid.nux, model.S.grid.nuy)
#         vic = vic + reshape(bred_vectors[n][(model.S.grid.nu+1):(model.S.grid.nu+model.S.grid.nv)], model.S.grid.nvx, model.S.grid.nvy)
#         etaic = etaic + reshape(bred_vectors[n][(model.S.grid.nu+model.S.grid.nv+1):end], model.S.grid.nx, model.S.grid.ny)

#         # Z[:, n] = [vec(P_kf.u); vec(P_kf.v); vec(P_kf.η)]

#         uic_new,vic_new,etaic_new = ShallowWaters.add_halo(uic,vic,etaic,P_kf.sst,S_kf)

#         S_kf.Prog.u = uic_new
#         S_kf.Prog.v = vic_new
#         S_kf.Prog.η = etaic_new

#         Diag = S_kf.Diag
#         Prog = S_kf.Prog

#         # for each ensemble member we want to do the steps that occur before the integration
#         @unpack u,v,η,sst = Prog
#         @unpack u0,v0,η0 = Diag.RungeKutta
#         @unpack u1,v1,η1 = Diag.RungeKutta
#         @unpack du,dv,dη = Diag.Tendencies
#         @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
#         @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
    
#         @unpack um,vm = Diag.SemiLagrange
    
#         @unpack dynamics,RKo,RKs,tracer_advection = S_kf.parameters
#         @unpack time_scheme,compensated = S_kf.parameters
#         @unpack RKaΔt,RKbΔt = S_kf.constants
#         @unpack Δt_Δ,Δt_Δs = S_kf.constants
    
#         @unpack nt,dtint = S_kf.grid
#         @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S_kf.grid
    
#         # calculate layer thicknesses for initial conditions
#         ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S_kf.forcing.H)
#         ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
#         ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
#         ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)
    
#         # calculate PV terms for initial conditions
#         urhs = S_kf.Diag.PrognosticVarsRHS.u .= S_kf.Prog.u
#         vrhs = S_kf.Diag.PrognosticVarsRHS.v .= S_kf.Prog.v
#         ηrhs = S_kf.Diag.PrognosticVarsRHS.η .= S_kf.Prog.η
    
#         ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S_kf)
#         ShallowWaters.PVadvection!(Diag,S_kf)
    
#         # propagate initial conditions
#         copyto!(u0,u)
#         copyto!(v0,v)
#         copyto!(η0,η)
    
#         # store initial conditions of sst for relaxation
#         copyto!(Diag.SemiLagrange.sst_ref,sst)

#         # store all of the ensemble models
#         push!(S_all, S_kf)

#     end

#     for i = 1:S_for_values.grid.nt

#         Progkf = []

#         for n = 1:N

#             p = one_step_function(S_all[n], i)
#             push!(Progkf, p)

#         end

#         if i ∈ data_steps
#             for k = 1:N

#                 Z[:, k] = [vec(Progkf[k].u); vec(Progkf[k].v); vec(Progkf[k].η)]

#                 if udata || udata && vdata || udata && vdata && etadata
#                     U[:, k] = Z[Int.(data_spots), k]
#                 elseif vdata
#                     U[:, k] = Z[Int.(data_spots) .+ 128*127, k]
#                 else etadata
#                     U[:, k] = Z[Int.(data_spots) .+ 2*127*128, k]
#                 end

#             end

#             E_fixed = (sigma_data .* randn(length(data_spots), N)) ./ sqrt(N-1)
#             d = data[:, j][data_spots]
#             D = d * ones(N)' #+ sqrt(N - 1) .* E_fixed
#             E = D * Π
#             A = Z * Π
#             Y = U * Π

#             if norm(D) === 0
#                 error("The data is zero")
#             end

#             D̃ = D - U
#             temp = Y*Y' + cov(E_fixed[:] * sqrt(N-1), corrected=false) .* I(length(data_spots))
#             # temp = Y*Y' + E_fixed*E_fixed'
#             tempinv = temp^(-1)
#             # tempinv = (temp' * temp)^(-1) * temp'
#             W = Y'*(tempinv)*D̃

            

#             Z += A*W ./ (sqrt(N - 1))

#             println("Norm of the ensemble array: ", norm(Z))

#             if any(isnan, Z)
#                 error("Ensemble array contains NaN values")
#             end

#             println("Norm of the difference between u and the updated u from Z: ", norm(vec(Progkf[1].u) .- Z[1:nu,1]))

#             for k = 1:N

#                 Progkf[k].u .= reshape(Z[1:nu,k],S_for_values.grid.nux,S_for_values.grid.nuy)
#                 Progkf[k].v .= reshape(Z[nu+1:nv+nu,k],S_for_values.grid.nvx,S_for_values.grid.nvy)
#                 Progkf[k].η .= reshape(Z[nv+nu+1:nu+nv+nT,k],S_for_values.grid.nx,S_for_values.grid.ny)

#                 u,v,eta = ShallowWaters.add_halo(Progkf[k].u,
#                     Progkf[k].v,
#                     Progkf[k].η,
#                     Progkf[k].sst,
#                     S_all[k]
#                 )

#                 S_all[k].Prog.u = u
#                 S_all[k].Prog.v = v
#                 S_all[k].Prog.η = eta

#             end

#             j += 1

#         end

#         # storing hourly data points
#         if i ∈ 9:9:S_for_values.grid.nt

#             kf_avgu = zeros(model.S.grid.nux,model.S.grid.nuy)
#             kf_avgv = zeros(model.S.grid.nvx,model.S.grid.nvy)
#             kf_avgeta = zeros(model.S.grid.nx,model.S.grid.ny)
#             for n = 1:N
#                 kf_avgu = kf_avgu .+ Progkf[n].u
#                 kf_avgv = kf_avgv .+ Progkf[n].v
#                 kf_avgeta = kf_avgeta .+ Progkf[n].η
#             end

#             push!(ekf_avgu, (kf_avgu)./N)
#             push!(ekf_avgv, (kf_avgv)./N)
#             push!(ekf_avgeta, (kf_avgeta)./N)

#         end

#     end

#     return ekf_avgu, ekf_avgv, ekf_avgeta

# end

function windstress_ensemble_kf(model, param_guess; udata=false,vdata=false,etadata=false)

    N = model.N
    data = model.data
    data_steps = model.data_steps
    data_spots = model.data_spots
    sigma_initcond = model.sigma_initcond
    sigma_data = model.sigma_data
    j = model.j

    # save the average u, v, and eta values from the data assimilation
    ekf_avgu = []
    ekf_avgv = []
    ekf_avgeta = []

    uic = model.S.parameters.T.(zeros(model.S.grid.nux,model.S.grid.nuy))
    vic = model.S.parameters.T.(zeros(model.S.grid.nvx,model.S.grid.nvy))
    etaic = model.S.parameters.T.(zeros(model.S.grid.nx,model.S.grid.ny))
    current = 1
    for m in (uic, vic, etaic)
        sz = prod(size(m))
        m .= reshape(param_guess[current:(current + sz - 1)], size(m)...)
        current += sz
    end

    Π = (I - (1 / N)*(ones(N) * ones(N)')) / sqrt(N - 1)
    E_fixed = (sigma_data .* randn(length(data_spots), N)) ./ sqrt(N-1)
    W = zeros(N,N)
    T = zeros(N,N)

    S_for_values = deepcopy(model.S)

    nu = S_for_values.grid.nu
    nv = S_for_values.grid.nv
    nT = S_for_values.grid.nT

    S = zeros(length(data_spots), N)
    U = zeros(length(data_spots), N)

    # Generate the initial model realization ensemble,
    # generated by slightly perturbing the initial condition N times.
    # Output will be stored in the matrix Z, and all model structs will be
    # stored in S_all
    # For the wind-stress experiment we're going to see the extent to which the EKF
    # can improve the perturbed (incorrect) wind-stress field, so the Fx field is added to
    # the columns in Z
    Z = zeros(model.S.grid.nu + model.S.grid.nv + model.S.grid.nT + 1, N)
    S_all = []

    bred_vectors = compute_bred_vectors(N,sigma_initcond,uic,vic,etaic,model.S.parameters)

    for n = 1:N

        S_kf = deepcopy(model.S)

        #only keeping this so I have an sst field without a halo for later step
        P_kf = ShallowWaters.PrognosticVars{S_kf.parameters.Tprog}(ShallowWaters.remove_halo(S_kf.Prog.u,
            S_kf.Prog.v,
            S_kf.Prog.η,
            S_kf.Prog.sst,
            S_kf)...
        )

        # using bred vectors to perturb initial condition in each ensemble member
        uic = uic + reshape(bred_vectors[n][1:model.S.grid.nu], model.S.grid.nux, model.S.grid.nuy)
        vic = vic + reshape(bred_vectors[n][(model.S.grid.nu+1):(model.S.grid.nu+model.S.grid.nv)], model.S.grid.nvx, model.S.grid.nvy)
        etaic = etaic + reshape(bred_vectors[n][(model.S.grid.nu+model.S.grid.nv+1):end], model.S.grid.nx, model.S.grid.ny)

        # Z[:, n] = [vec(P_kf.u); vec(P_kf.v); vec(P_kf.η)]

        uic_new,vic_new,etaic_new = ShallowWaters.add_halo(uic,vic,etaic,P_kf.sst,S_kf)

        S_kf.Prog.u = uic_new
        S_kf.Prog.v = vic_new
        S_kf.Prog.η = etaic_new

        # perturbing the wind stress forcing amplitude
        S_kf.parameters.Fx0 = model.pred_forcing + randn(1)[1] * model.sigma_forcing

        Diag = S_kf.Diag
        Prog = S_kf.Prog

        # for each ensemble member we want to do the steps that occur before the integration
        @unpack u,v,η,sst = Prog
        @unpack u0,v0,η0 = Diag.RungeKutta
        @unpack u1,v1,η1 = Diag.RungeKutta
        @unpack du,dv,dη = Diag.Tendencies
        @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
        @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
    
        @unpack um,vm = Diag.SemiLagrange
    
        @unpack dynamics,RKo,RKs,tracer_advection = S_kf.parameters
        @unpack time_scheme,compensated = S_kf.parameters
        @unpack RKaΔt,RKbΔt = S_kf.constants
        @unpack Δt_Δ,Δt_Δs = S_kf.constants
    
        @unpack nt,dtint = S_kf.grid
        @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S_kf.grid
    
        # calculate layer thicknesses for initial conditions
        ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S_kf.forcing.H)
        ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
        ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
        ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)
    
        # calculate PV terms for initial conditions
        urhs = S_kf.Diag.PrognosticVarsRHS.u .= S_kf.Prog.u
        vrhs = S_kf.Diag.PrognosticVarsRHS.v .= S_kf.Prog.v
        ηrhs = S_kf.Diag.PrognosticVarsRHS.η .= S_kf.Prog.η
    
        ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S_kf)
        ShallowWaters.PVadvection!(Diag,S_kf)
    
        # propagate initial conditions
        copyto!(u0,u)
        copyto!(v0,v)
        copyto!(η0,η)
    
        # store initial conditions of sst for relaxation
        copyto!(Diag.SemiLagrange.sst_ref,sst)

        # store all of the ensemble models
        push!(S_all, S_kf)

    end

    for i = 1:S_for_values.grid.nt

        Progkf = []

        for n = 1:N

            p = one_step_function(S_all[n], i)
            push!(Progkf, p)

        end

        if i ∈ data_steps
            for k = 1:N

                Z[:, k] = [vec(Progkf[k].u); vec(Progkf[k].v); vec(Progkf[k].η); S_all[k].parameters.Fx0]

                if udata || udata && vdata || udata && vdata && etadata
                    U[:, k] = Z[Int.(data_spots), k]
                elseif vdata
                    U[:, k] = Z[Int.(data_spots) .+ 128*127, k]
                else etadata
                    U[:, k] = Z[Int.(data_spots) .+ 2*127*128, k]
                end

            end

            d = data[:, j][data_spots]
            D = d * ones(N)' + sqrt(N - 1) .* E_fixed
            E = D * Π
            A = Z * Π
            Y = U * Π

            D̃ = D - U
            temp = Y*Y' + E*E'
            tempinv = (temp' * temp) * temp'
            W = Y'*(tempinv)*D̃

            Z += A*W ./ (sqrt(N - 1))

            if any(isnan, Z)
                error("Ensemble array contains NaN values")
            end

            for k = 1:N

                Progkf[k].u .= reshape(Z[1:nu,k],S_for_values.grid.nux,S_for_values.grid.nuy)
                Progkf[k].v .= reshape(Z[nu+1:nv+nu,k],S_for_values.grid.nvx,S_for_values.grid.nvy)
                Progkf[k].η .= reshape(Z[nv+nu+1:nu+nv+nT,k],S_for_values.grid.nx,S_for_values.grid.ny)

                u,v,eta = ShallowWaters.add_halo(Progkf[k].u,
                    Progkf[k].v,
                    Progkf[k].η,
                    Progkf[k].sst,
                    S_all[k]
                )

                S_all[k].Prog.u = u
                S_all[k].Prog.v = v
                S_all[k].Prog.η = eta
                S_all[k].parameters.Fx0 = Z[end, k]

            end

            j += 1

        end

        # storing hourly data points
        if i ∈ 9:9:S_for_values.grid.nt

            kf_avgu = zeros(model.S.grid.nux,model.S.grid.nuy)
            kf_avgv = zeros(model.S.grid.nvx,model.S.grid.nvy)
            kf_avgeta = zeros(model.S.grid.nx,model.S.grid.ny)
            for n = 1:N
                kf_avgu = kf_avgu .+ Progkf[n].u
                kf_avgv = kf_avgv .+ Progkf[n].v
                kf_avgeta = kf_avgeta .+ Progkf[n].η
            end

            push!(ekf_avgu, (kf_avgu)./N)
            push!(ekf_avgv, (kf_avgv)./N)
            push!(ekf_avgeta, (kf_avgeta)./N)

        end

    end

    return ekf_avgu, ekf_avgv, ekf_avgeta

end

function bottomdrag_ensemble_kf(model, param_guess; udata=false,vdata=false,etadata=false)

    N = model.N
    data = model.data
    data_steps = model.data_steps
    data_spots = model.data_spots
    sigma_initcond = model.sigma_initcond
    sigma_data = model.sigma_data
    j = model.j

    # save the average u, v, and eta values from the data assimilation
    ekf_avgu = []
    ekf_avgv = []
    ekf_avgeta = []

    uic = model.S.parameters.T.(zeros(model.S.grid.nux,model.S.grid.nuy))
    vic = model.S.parameters.T.(zeros(model.S.grid.nvx,model.S.grid.nvy))
    etaic = model.S.parameters.T.(zeros(model.S.grid.nx,model.S.grid.ny))
    current = 1
    for m in (uic, vic, etaic)
        sz = prod(size(m))
        m .= reshape(param_guess[current:(current + sz - 1)], size(m)...)
        current += sz
    end

    Π = (I - (1 / N)*(ones(N) * ones(N)')) / sqrt(N - 1)
    W = zeros(N,N)
    T = zeros(N,N)

    S_for_values = deepcopy(model.S)

    nu = S_for_values.grid.nu
    nv = S_for_values.grid.nv
    nT = S_for_values.grid.nT

    S = zeros(length(data_spots), N)
    U = zeros(length(data_spots), N)

    # Generate the initial model realization ensemble,
    # generated by slightly perturbing the initial condition N times.
    # Output will be stored in the matrix Z, and all model structs will be
    # stored in S_all
    # For the wind-stress experiment we're going to see the extent to which the EKF
    # can improve the perturbed (incorrect) wind-stress field, so the Fx field is added to
    # the columns in Z
    Z = zeros(model.S.grid.nu + model.S.grid.nv + model.S.grid.nT, N)
    S_all = []

    bred_vectors = compute_bred_vectors(N,sigma_initcond,uic,vic,etaic,model.S.parameters)

    for n = 1:N

        S_kf = deepcopy(model.S)

        #only keeping this so I have an sst field without a halo for later step
        P_kf = ShallowWaters.PrognosticVars{S_kf.parameters.Tprog}(ShallowWaters.remove_halo(S_kf.Prog.u,
            S_kf.Prog.v,
            S_kf.Prog.η,
            S_kf.Prog.sst,
            S_kf)...
        )

        # using bred vectors to perturb initial condition in each ensemble member
        uic = uic + reshape(bred_vectors[n][1:model.S.grid.nu], model.S.grid.nux, model.S.grid.nuy)
        vic = vic + reshape(bred_vectors[n][(model.S.grid.nu+1):(model.S.grid.nu+model.S.grid.nv)], model.S.grid.nvx, model.S.grid.nvy)
        etaic = etaic + reshape(bred_vectors[n][(model.S.grid.nu+model.S.grid.nv+1):end], model.S.grid.nx, model.S.grid.ny)

        # Z[:, n] = [vec(P_kf.u); vec(P_kf.v); vec(P_kf.η)]

        uic_new,vic_new,etaic_new = ShallowWaters.add_halo(uic,vic,etaic,P_kf.sst,S_kf)

        S_kf.Prog.u = uic_new
        S_kf.Prog.v = vic_new
        S_kf.Prog.η = etaic_new

        Diag = S_kf.Diag
        Prog = S_kf.Prog

        # for each ensemble member we want to do the steps that occur before the integration
        @unpack u,v,η,sst = Prog
        @unpack u0,v0,η0 = Diag.RungeKutta
        @unpack u1,v1,η1 = Diag.RungeKutta
        @unpack du,dv,dη = Diag.Tendencies
        @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
        @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
    
        @unpack um,vm = Diag.SemiLagrange
    
        @unpack dynamics,RKo,RKs,tracer_advection = S_kf.parameters
        @unpack time_scheme,compensated = S_kf.parameters
        @unpack RKaΔt,RKbΔt = S_kf.constants
        @unpack Δt_Δ,Δt_Δs = S_kf.constants
    
        @unpack nt,dtint = S_kf.grid
        @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S_kf.grid
    
        # calculate layer thicknesses for initial conditions
        ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S_kf.forcing.H)
        ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
        ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
        ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)
    
        # calculate PV terms for initial conditions
        urhs = S_kf.Diag.PrognosticVarsRHS.u .= S_kf.Prog.u
        vrhs = S_kf.Diag.PrognosticVarsRHS.v .= S_kf.Prog.v
        ηrhs = S_kf.Diag.PrognosticVarsRHS.η .= S_kf.Prog.η
    
        ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S_kf)
        ShallowWaters.PVadvection!(Diag,S_kf)
    
        # propagate initial conditions
        copyto!(u0,u)
        copyto!(v0,v)
        copyto!(η0,η)
    
        # store initial conditions of sst for relaxation
        copyto!(Diag.SemiLagrange.sst_ref,sst)

        # store all of the ensemble models
        push!(S_all, S_kf)

    end

    for i = 1:S_for_values.grid.nt

        Progkf = []

        for n = 1:N

            p = one_step_function(S_all[n], i)
            push!(Progkf, p)

        end

        if i ∈ data_steps

            for k = 1:N

                Z[:, k] = [vec(Progkf[k].u); vec(Progkf[k].v); vec(Progkf[k].η)]

                if udata || udata && vdata || udata && vdata && etadata
                    U[:, k] = Z[Int.(data_spots), k]
                elseif vdata
                    U[:, k] = Z[Int.(data_spots) .+ 128*127, k]
                else etadata
                    U[:, k] = Z[Int.(data_spots) .+ 2*127*128, k]
                end

            end

            d = data[:, j][data_spots]
            E = (sigma_data .* randn(length(data_spots), N)) ./ sqrt(N-1)
            D = d * ones(N)' + sqrt(N - 1) .* E
            E = D * Π
            A = Z * Π
            Y = U * Π

            D̃ = D - U
            temp = Y*Y' + E*E'
            tempinv = (temp' * temp) * temp'
            W = Y'*(tempinv)*D̃

            Z = Z + A*W ./ (sqrt(N - 1))

            for k = 1:N

                Progkf[k].u .= reshape(Z[1:nu,k],S_for_values.grid.nux,S_for_values.grid.nuy)
                Progkf[k].v .= reshape(Z[nu+1:nv+nu,k],S_for_values.grid.nvx,S_for_values.grid.nvy)
                Progkf[k].η .= reshape(Z[nv+nu+1:nu+nv+nT,k],S_for_values.grid.nx,S_for_values.grid.ny)

                u,v,eta = ShallowWaters.add_halo(Progkf[k].u,
                    Progkf[k].v,
                    Progkf[k].η,
                    Progkf[k].sst,
                    S_all[k]
                )

                S_all[k].Prog.u = u
                S_all[k].Prog.v = v
                S_all[k].Prog.η = eta

            end

            j += 1

        end

        # storing hourly data points
        if i ∈ 9:9:S_for_values.grid.nt

            kf_avgu = zeros(model.S.grid.nux,model.S.grid.nuy)
            kf_avgv = zeros(model.S.grid.nvx,model.S.grid.nvy)
            kf_avgeta = zeros(model.S.grid.nx,model.S.grid.ny)
            for n = 1:N
                kf_avgu = kf_avgu .+ Progkf[n].u
                kf_avgv = kf_avgv .+ Progkf[n].v
                kf_avgeta = kf_avgeta .+ Progkf[n].η
            end

            push!(ekf_avgu, (kf_avgu)./N)
            push!(ekf_avgv, (kf_avgv)./N)
            push!(ekf_avgeta, (kf_avgeta)./N)

        end

    end

    return ekf_avgu, ekf_avgv, ekf_avgeta

end

"""
Trying something
"""

function run_ensemble_kf(model, param_guess; udata=false,vdata=false,etadata=false)

    N = model.N
    data = model.data
    data_steps = model.data_steps
    data_spots = model.data_spots
    sigma_initcond = model.sigma_initcond
    sigma_data = model.sigma_data
    j = model.j

    # save the average u, v, and eta values from the data assimilation
    ekf_avgu = []
    ekf_avgv = []
    ekf_avgeta = []

    uic = model.S.parameters.T.(zeros(model.S.grid.nux,model.S.grid.nuy))
    vic = model.S.parameters.T.(zeros(model.S.grid.nvx,model.S.grid.nvy))
    etaic = model.S.parameters.T.(zeros(model.S.grid.nx,model.S.grid.ny))
    current = 1
    for m in (uic, vic, etaic)
        sz = prod(size(m))
        m .= reshape(param_guess[current:(current + sz - 1)], size(m)...)
        current += sz
    end

    Π = (I - (1 / N)*(ones(N) * ones(N)')) / sqrt(N - 1)
    W = zeros(N,N)
    T = zeros(N,N)

    S_for_values = deepcopy(model.S)

    nu = S_for_values.grid.nu
    nv = S_for_values.grid.nv
    nT = S_for_values.grid.nT

    S = zeros(length(data_spots), N)
    U = zeros(length(data_spots), N)

    # Generate the initial model realization ensemble,
    # generated by slightly perturbing the initial condition N times.
    # Output will be stored in the matrix Z, and all model structs will be
    # stored in S_all
    # We assume that Z is the total state vector in size, so 48896 is the
    # whole length of u + v + eta as a column vector
    Z = zeros(model.S.grid.nu + model.S.grid.nv + model.S.grid.nT, N)
    S_all = []

    bred_vectors = compute_bred_vectors(N,sigma_initcond,uic,vic,etaic,model.S.parameters)

    for n = 1:N

        S_kf = deepcopy(model.S)

        #only keeping this so I have an sst field without a halo for later step
        P_kf = ShallowWaters.PrognosticVars{S_kf.parameters.Tprog}(ShallowWaters.remove_halo(S_kf.Prog.u,
            S_kf.Prog.v,
            S_kf.Prog.η,
            S_kf.Prog.sst,
            S_kf)...
        )

        # using bred vectors to perturb initial condition in each ensemble member
        uic = uic + reshape(bred_vectors[n][1:model.S.grid.nu], model.S.grid.nux, model.S.grid.nuy)
        vic = vic + reshape(bred_vectors[n][(model.S.grid.nu+1):(model.S.grid.nu+model.S.grid.nv)], model.S.grid.nvx, model.S.grid.nvy)
        etaic = etaic + reshape(bred_vectors[n][(model.S.grid.nu+model.S.grid.nv+1):end], model.S.grid.nx, model.S.grid.ny)

        uic_new,vic_new,etaic_new = ShallowWaters.add_halo(uic,vic,etaic,P_kf.sst,S_kf)

        S_kf.Prog.u = uic_new
        S_kf.Prog.v = vic_new
        S_kf.Prog.η = etaic_new

        Diag = S_kf.Diag
        Prog = S_kf.Prog

        # for each ensemble member we want to do the steps that occur before the integration
        @unpack u,v,η,sst = Prog
        @unpack u0,v0,η0 = Diag.RungeKutta
        @unpack u1,v1,η1 = Diag.RungeKutta
        @unpack du,dv,dη = Diag.Tendencies
        @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
        @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
    
        @unpack um,vm = Diag.SemiLagrange
    
        @unpack dynamics,RKo,RKs,tracer_advection = S_kf.parameters
        @unpack time_scheme,compensated = S_kf.parameters
        @unpack RKaΔt,RKbΔt = S_kf.constants
        @unpack Δt_Δ,Δt_Δs = S_kf.constants
    
        @unpack nt,dtint = S_kf.grid
        @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S_kf.grid
    
        # calculate layer thicknesses for initial conditions
        ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S_kf.forcing.H)
        ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
        ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
        ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)
    
        # calculate PV terms for initial conditions
        urhs = S_kf.Diag.PrognosticVarsRHS.u .= S_kf.Prog.u
        vrhs = S_kf.Diag.PrognosticVarsRHS.v .= S_kf.Prog.v
        ηrhs = S_kf.Diag.PrognosticVarsRHS.η .= S_kf.Prog.η
    
        ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S_kf)
        ShallowWaters.PVadvection!(Diag,S_kf)
    
        # propagate initial conditions
        copyto!(u0,u)
        copyto!(v0,v)
        copyto!(η0,η)
    
        # store initial conditions of sst for relaxation
        copyto!(Diag.SemiLagrange.sst_ref,sst)

        # store all of the ensemble models
        push!(S_all, S_kf)

    end

    for i = 1:S_for_values.grid.nt

        Progkf = []

        for n = 1:N

            t = S_all[n].t

            # ghost point copy for boundary conditions
            ShallowWaters.ghost_points!(S_all[n].Prog.u, S_all[n].Prog.v, S_all[n].Prog.η, S_all[n])
            copyto!(S_all[n].Diag.RungeKutta.u1, S_all[n].Prog.u)
            copyto!(S_all[n].Diag.RungeKutta.v1, S_all[n].Prog.v)
            copyto!(S_all[n].Diag.RungeKutta.η1, S_all[n].Prog.η)

            if S_all[n].parameters.compensated
                fill!(S_all[n].Diag.Tendencies.du_sum, zero(S_all[n].parameters.Tprog))
                fill!(S_all[n].Diag.Tendencies.dv_sum, zero(S_all[n].parameters.Tprog))
                fill!(S_all[n].Diag.Tendencies.dη_sum, zero(S_all[n].parameters.Tprog))
            end

            for rki = 1:S_all[n].parameters.RKo
                if rki > 1
                    ShallowWaters.ghost_points!(
                        S_all[n].Diag.RungeKutta.u1,
                        S_all[n].Diag.RungeKutta.v1,
                        S_all[n].Diag.RungeKutta.η1,
                        S_all[n]
                    )
                end

                # type conversion for mixed precision
                u1rhs = S_all[n].Diag.PrognosticVarsRHS.u .= S_all[n].Diag.RungeKutta.u1
                v1rhs = S_all[n].Diag.PrognosticVarsRHS.v .= S_all[n].Diag.RungeKutta.v1
                η1rhs = S_all[n].Diag.PrognosticVarsRHS.η .= S_all[n].Diag.RungeKutta.η1

                ShallowWaters.rhs!(u1rhs, v1rhs, η1rhs, S_all[n].Diag, S_all[n], t)          # momentum only
                ShallowWaters.continuity!(u1rhs, v1rhs, η1rhs, S_all[n].Diag, S_all[n], t)   # continuity equation

                if rki < S_all[n].parameters.RKo
                    ShallowWaters.caxb!(
                        S_all[n].Diag.RungeKutta.u1,
                        S_all[n].Prog.u,
                        S_all[n].constants.RKbΔt[rki],
                        S_all[n].Diag.Tendencies.du
                    )
                    ShallowWaters.caxb!(
                        S_all[n].Diag.RungeKutta.v1,
                        S_all[n].Prog.v,
                        S_all[n].constants.RKbΔt[rki],
                        S_all[n].Diag.Tendencies.dv
                    )
                    ShallowWaters.caxb!(
                        S_all[n].Diag.RungeKutta.η1,
                        S_all[n].Prog.η,
                        S_all[n].constants.RKbΔt[rki],
                        S_all[n].Diag.Tendencies.dη
                    )
                end

                if S_all[n].parameters.compensated
                    ShallowWaters.axb!(S_all[n].Diag.Tendencies.du_sum, S_all[n].constants.RKaΔt[rki], S_all[n].Diag.Tendencies.du)
                    ShallowWaters.axb!(S_all[n].Diag.Tendencies.dv_sum, S_all[n].constants.RKaΔt[rki], S_all[n].Diag.Tendencies.dv)
                    ShallowWaters.axb!(S_all[n].Diag.Tendencies.dη_sum, S_all[n].constants.RKaΔt[rki], S_all[n].Diag.Tendencies.dη)
                else
                    ShallowWaters.axb!(
                        S_all[n].Diag.RungeKutta.u0,
                        S_all[n].constants.RKaΔt[rki],
                        S_all[n].Diag.Tendencies.du
                    )
                    ShallowWaters.axb!(
                        S_all[n].Diag.RungeKutta.v0,
                        S_all[n].constants.RKaΔt[rki],
                        S_all[n].Diag.Tendencies.dv
                    )
                    ShallowWaters.axb!(
                        S_all[n].Diag.RungeKutta.η0,
                        S_all[n].constants.RKaΔt[rki],
                        S_all[n].Diag.Tendencies.dη
                    )
                end
            end

            if S_all[n].parameters.compensated
                ShallowWaters.axb!(S_all[n].Diag.Tendencies.du_sum, -1, S_all[n].Diag.Tendencies.du_comp)
                ShallowWaters.axb!(S_all[n].Diag.Tendencies.dv_sum, -1, S_all[n].Diag.Tendencies.dv_comp)
                ShallowWaters.axb!(S_all[n].Diag.Tendencies.dη_sum, -1, S_all[n].Diag.Tendencies.dη_comp)

                ShallowWaters.axb!(S_all[n].Diag.RungeKutta.u0, 1, S_all[n].Diag.Tendencies.du_sum)
                ShallowWaters.axb!(S_all[n].Diag.RungeKutta.v0, 1, S_all[n].Diag.Tendencies.dv_sum)
                ShallowWaters.axb!(S_all[n].Diag.RungeKutta.η0, 1, S_all[n].Diag.Tendencies.dη_sum)

                ShallowWaters.dambmc!(
                    S_all[n].Diag.Tendencies.du_comp,
                    S_all[n].Diag.RungeKutta.u0,
                    S_all[n].Prog.u,
                    S_all[n].Diag.Tendencies.du_sum
                )
                ShallowWaters.dambmc!(
                    S_all[n].Diag.Tendencies.dv_comp,
                    S_all[n].Diag.RungeKutta.v0,
                    S_all[n].Prog.v,
                    S_all[n].Diag.Tendencies.dv_sum
                )
                ShallowWaters.dambmc!(
                    S_all[n].Diag.Tendencies.dη_comp,
                    S_all[n].Diag.RungeKutta.η0,
                    S_all[n].Prog.η,
                    S_all[n].Diag.Tendencies.dη_sum
                )
            end

            ShallowWaters.ghost_points!(
                S_all[n].Diag.RungeKutta.u0,
                S_all[n].Diag.RungeKutta.v0,
                S_all[n].Diag.RungeKutta.η0,
                S_all[n]
            )

            u0rhs = S_all[n].Diag.PrognosticVarsRHS.u .= S_all[n].Diag.RungeKutta.u0
            v0rhs = S_all[n].Diag.PrognosticVarsRHS.v .= S_all[n].Diag.RungeKutta.v0
            η0rhs = S_all[n].Diag.PrognosticVarsRHS.η .= S_all[n].Diag.RungeKutta.η0

            if S_all[n].parameters.dynamics == "nonlinear" && S_all[n].grid.nstep_advcor > 0 && (i % S_all[n].grid.nstep_advcor) == 0
                ShallowWaters.UVfluxes!(u0rhs, v0rhs, η0rhs, S_all[n].Diag, S_all[n])
                ShallowWaters.advection_coriolis!(u0rhs, v0rhs, η0rhs, S_all[n].Diag, S_all[n])
            end

            if (i % S_all[n].grid.nstep_diff) == 0
                ShallowWaters.bottom_drag!(u0rhs, v0rhs, η0rhs, S_all[n].Diag, S_all[n])
                ShallowWaters.diffusion!(u0rhs, v0rhs, S_all[n].Diag, S_all[n])
                ShallowWaters.add_drag_diff_tendencies!(
                    S_all[n].Diag.RungeKutta.u0,
                    S_all[n].Diag.RungeKutta.v0,
                    S_all[n].Diag,
                    S_all[n]
                )
                ShallowWaters.ghost_points_uv!(
                    S_all[n].Diag.RungeKutta.u0,
                    S_all[n].Diag.RungeKutta.v0,
                    S_all[n]
                )
            end

            t += S_all[n].grid.dtint

            u0rhs = S_all[n].Diag.PrognosticVarsRHS.u .= S_all[n].Diag.RungeKutta.u0
            v0rhs = S_all[n].Diag.PrognosticVarsRHS.v .= S_all[n].Diag.RungeKutta.v0
            ShallowWaters.tracer!(i, u0rhs, v0rhs, S_all[n].Prog, S_all[n].Diag, S_all[n])

            copyto!(S_all[n].Prog.u, S_all[n].Diag.RungeKutta.u0)
            copyto!(S_all[n].Prog.v, S_all[n].Diag.RungeKutta.v0)
            copyto!(S_all[n].Prog.η, S_all[n].Diag.RungeKutta.η0)

            push!(Progkf, ShallowWaters.PrognosticVars{Float64}(ShallowWaters.remove_halo(
                S_all[n].Prog.u,
                S_all[n].Prog.v,
                S_all[n].Prog.η,
                S_all[n].Prog.sst,
                S_all[n]
                )...)
            )

        end

        if i in data_steps

            for n = 1:N
                Z[:, n] = [vec(Progkf[n].u); vec(Progkf[n].v); vec(Progkf[n].η)]

                if udata || udata && vdata || udata && vdata && etadata
                    U[:, n] = Z[Int.(data_spots), n]
                elseif vdata
                    U[:, n] = Z[Int.(data_spots) .+ 128*127, n]
                else etadata
                    U[:, n] = Z[Int.(data_spots) .+ 2*127*128, n]
                end
            end

            E_fixed = (sigma_data .* randn(length(data_spots), N)) ./ sqrt(N-1)
            d = data[:, j][data_spots]
            D = d * ones(N)' + sqrt(N - 1) .* E_fixed
            # E = D * Π
            A = Z * Π
            Y = U * Π

            if norm(D) == 0
                error("The data is zero")
            end

            D̃ = D - U
            temp = Y*Y' + cov(E_fixed[:] * sqrt(N-1), corrected=false) .* I(length(data_spots))
            # temp = Y*Y' + E_fixed*E_fixed'
            tempinv = temp^(-1)
            # tempinv = (temp' * temp)^(-1) * temp'
            W = Y'*(tempinv)*D̃

            Z += A*W #./ (sqrt(N - 1))

            println("Norm of the ensemble array: ", norm(Z))

            if any(isnan, Z)
                error("Ensemble array contains NaN values")
            end

            println("Norm of the difference between u and the updated u from Z: ", norm(vec(Progkf[1].u) .- Z[1:nu,1]))

            for n = 1:N
                Progkf[n].u .= reshape(Z[1:nu,n],S_for_values.grid.nux,S_for_values.grid.nuy)
                Progkf[n].v .= reshape(Z[nu+1:nv+nu,n],S_for_values.grid.nvx,S_for_values.grid.nvy)
                Progkf[n].η .= reshape(Z[nv+nu+1:nu+nv+nT,n],S_for_values.grid.nx,S_for_values.grid.ny)

                u,v,eta = ShallowWaters.add_halo(Progkf[n].u,
                    Progkf[n].v,
                    Progkf[n].η,
                    Progkf[n].sst,
                    S_all[n]
                )

                S_all[n].Prog.u .= u
                S_all[n].Prog.v .= v
                S_all[n].Prog.η .= eta

                # if norm(vec(u) .- Z[1:nu, n]) !== 0.0
                #     println("The updated Z values are not getting stored in the model")
                #     return
                # end
            end

            j += 1

        end

        # storing hourly data points
        if i ∈ 9:9:S_for_values.grid.nt
            kf_avgu = zeros(model.S.grid.nux,model.S.grid.nuy)
            kf_avgv = zeros(model.S.grid.nvx,model.S.grid.nvy)
            kf_avgeta = zeros(model.S.grid.nx,model.S.grid.ny)
            for n = 1:N
                kf_avgu = kf_avgu .+ Progkf[n].u
                kf_avgv = kf_avgv .+ Progkf[n].v
                kf_avgeta = kf_avgeta .+ Progkf[n].η
            end
            push!(ekf_avgu, (kf_avgu)./N)
            push!(ekf_avgv, (kf_avgv)./N)
            push!(ekf_avgeta, (kf_avgeta)./N)
        end

    end

    return ekf_avgu, ekf_avgv, ekf_avgeta

end

"""
This function will create N (the number of ensembles) Bred vectors, which
will get used as the initial perturbations for the EKF
"""
function compute_bred_vectors(N, sigma_initcond, uic_nohalo, vic_nohalo, etaic_nohalo, parameters)

    utrue = ncread("./data_files/128_postspinup_30days_hourlysaves/u.nc", "u")[:,:,1];
    etatrue = ncread("./data_files/128_postspinup_30days_hourlysaves/eta.nc", "eta")[:,:,1];

    sigma_bvu = ( (sum(abs.(utrue .- uic_nohalo)) / (128*127)) )/ 5
    sigma_bveta = ( (sum(abs.(etatrue .- etaic_nohalo)) / (128^2)) )/ 5

    println("sigma_bvu: ", sigma_bvu)
    println("sigma_bveta: ", sigma_bveta)

    bred_vectors = []

    for n = 1:N

        P = parameters
        S1 = ShallowWaters.model_setup(P)
        S2 = ShallowWaters.model_setup(P)

        S1.parameters.Ndays = 1
        S2.parameters.Ndays = 1

        upred,vpred,etapred,_ = ShallowWaters.add_halo(uic_nohalo,vic_nohalo,etaic_nohalo,zeros(128,128),S1)

        # S1 will iterate the original unperturbed solution
        S1.Prog.u = copy(upred)
        S1.Prog.v = copy(vpred)
        S1.Prog.η = copy(etapred)

        # S2 will iterate the perturbed solutions
        S2.Prog.u = copy(upred)
        S2.Prog.v = copy(vpred)
        S2.Prog.η = copy(etapred)

        Prog = ShallowWaters.PrognosticVars{Float64}(ShallowWaters.remove_halo(S2.Prog.u,
            S2.Prog.v,
            S2.Prog.η,
            S2.Prog.sst,
            S2)...
        )

        # perturb initial conditions from the guessed value for each ensemble member
        upert = sigma_bvu .* randn(size(Prog.u))
        vpert = sigma_bvu .* randn(size(Prog.v))
        etapert = sigma_bveta .* randn(size(Prog.η))

        # computing norms of the initial perturbations
        Au = norm(upert)
        Av = norm(vpert)
        Aeta = norm(etapert)

        # apply the perturbation to the initial condition
        Prog.u = Prog.u + upert
        Prog.v = Prog.v + vpert
        Prog.η = Prog.η + etapert

        uperturbed,vperturbed,etaperturbed,_ = ShallowWaters.add_halo(Prog.u,Prog.v,Prog.η,zeros(128,128),S2)

        # store this in S2
        S2.Prog.u = uperturbed
        S2.Prog.v = vperturbed
        S2.Prog.η = etaperturbed

        # Store the two initial models to be integrated
        S_all = []
        push!(S_all, S1)
        push!(S_all, S2)

        # code that appears before the time integration
        for S in S_all

            Diag = S.Diag
            Prog = S.Prog
        
            @unpack u,v,η,sst = Prog
            @unpack u0,v0,η0 = Diag.RungeKutta
            @unpack u1,v1,η1 = Diag.RungeKutta
            @unpack du,dv,dη = Diag.Tendencies
            @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
            @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
        
            @unpack um,vm = Diag.SemiLagrange
        
            @unpack dynamics,RKo,RKs,tracer_advection = S.parameters
            @unpack time_scheme,compensated = S.parameters
            @unpack RKaΔt,RKbΔt = S.constants
            @unpack Δt_Δ,Δt_Δs = S.constants
        
            @unpack nt,dtint = S.grid
            @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S.grid
        
            # calculate layer thicknesses for initial conditions
            ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S.forcing.H)
            ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
            ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
            ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)

            # calculate PV terms for initial conditions
            urhs = S.Diag.PrognosticVarsRHS.u .= S.Prog.u
            vrhs = S.Diag.PrognosticVarsRHS.v .= S.Prog.v
            ηrhs = S.Diag.PrognosticVarsRHS.η .= S.Prog.η
        
            ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S)
            ShallowWaters.PVadvection!(Diag,S)
        
            # propagate initial conditions
            copyto!(u0,u)
            copyto!(v0,v)
            copyto!(η0,η)
        
            # store initial conditions of sst for relaxation
            copyto!(Diag.SemiLagrange.sst_ref,sst)
        end

        # I need to change this to be (1) do the following for one day, get the new perturbation, perturb, and then restart the day
        for i = 1:20

            if i === 20

                S_all[1].parameters.Ndays=1
                S_all[2].parameters.Ndays=1

                p1 = ShallowWaters.time_integration(deepcopy(S_all[1]));
                p2 = ShallowWaters.time_integration(deepcopy(S_all[2]));

                normu = norm(p1.u - p2.u)
                normv = norm(p1.v - p2.v)
                normeta = norm(p1.η - p2.η)

                uperturbation = (p1.u - p2.u) * (Au / normu)
                vperturbation = (p1.v - p2.v) * (Av / normv)
                etaperturbation = (p1.η - p2.η) * (Aeta / normeta)

                push!(bred_vectors, [vec(uperturbation); vec(vperturbation); vec(etaperturbation)])

                println("Norm of first bred vector minus the latest: ", norm(bred_vectors[1] .- [vec(uperturbation); vec(vperturbation); vec(etaperturbation)]))
                println("Norm of current bred vector: ", norm([vec(uperturbation); vec(vperturbation); vec(etaperturbation)]))


            end

            S_all[1].parameters.Ndays=1
            S_all[2].parameters.Ndays=1

            p1 = ShallowWaters.time_integration(deepcopy(S_all[1]));
            p2 = ShallowWaters.time_integration(deepcopy(S_all[2]));

            normu = norm(p2.u)
            normv = norm(p2.v)
            normeta = norm(p2.η)

            uperturbation = (p1.u - p2.u) * (Au / normu)
            vperturbation = (p1.v - p2.v) * (Av / normv)
            etaperturbation = (p1.η - p2.η) * (Aeta / normeta)

            Prog1 = ShallowWaters.PrognosticVars{Float64}(ShallowWaters.remove_halo(S_all[1].Prog.u,
                S_all[1].Prog.v,
                S_all[1].Prog.η,
                S_all[1].Prog.sst,
                S_all[1])...
            )
            Prog1.u .= uic_nohalo
            Prog1.v .= vic_nohalo
            Prog1.η .= etaic_nohalo

            Prog2 = ShallowWaters.PrognosticVars{Float64}(ShallowWaters.remove_halo(S_all[2].Prog.u,
                S_all[2].Prog.v,
                S_all[2].Prog.η,
                S_all[2].Prog.sst,
                S_all[2])...
            )

            Prog2.u = copy(Prog1.u) + uperturbation
            Prog2.v = copy(Prog1.v) + vperturbation
            Prog2.η = copy(Prog1.η) + etaperturbation

            uic,vic,etaic,_ = ShallowWaters.add_halo(Prog2.u,Prog2.v,Prog2.η,Prog2.sst,S_all[2])

            S_all[2].Prog.u = uic
            S_all[2].Prog.v = vic
            S_all[2].Prog.η = etaic

            # upred,vpred,etapred,_ = ShallowWaters.add_halo(Prog1.u,Prog1.v,Prog1.η,zeros(128,128),S_all[1])

            # # S1 will iterate the original unperturbed solution
            # S1.Prog.u = copy(upred)
            # S1.Prog.v = copy(vpred)
            # S1.Prog.η = copy(etapred)

        end

    end

    return bred_vectors

end