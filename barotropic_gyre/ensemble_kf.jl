# We need a version of the integration function that runs a single timestep and 
# takes as input the current prognostic fields. This function will then be
# passed to Enzyme for computing the Jacobian, which can subsequently be used
# in the Kalman filter. We're giving as input uveta, which will be a block
# vector of the fields u, v, and eta in that order. The restructuring of the
# arrays will be as columns stacked on top of eachother, e.g. the first column becomes
# the first bit of the vector, the second column the second bit, and so on.

using Parameters
# Enzyme.API.looseTypeAnalysis!(true)

"""
This function will run the ensemble Kalman filter. It needs to be given:
    N - the number of ensembles to build
    Ndays - the number of days to integrate
    data - the data to be used
    data_steps - where we assume data exists
    data_spots - the spatial locations within Z (dim(Z) = state_vector x number of ensembles)
      where we assume data to exist. This could be all of u, it could be specific locations in u
    sigma_initcond - std of noise added to initial condition for each of the ensembles
    sigma_data - std of the noise added to data
"""
function run_ensemble_kf(N, data, param_guess, data_spots, sigma_initcond, sigma_data;
    kwargs...
    )

    # save the average u and v values from the data assimilation
    ekf_avgu = []
    ekf_avgv = []

    uic = reshape(param_guess[1:17292], 131, 132)
    vic = reshape(param_guess[17293:34584], 132, 131)
    etaic = reshape(param_guess[34585:end], 130, 130)

    Π = (I - (1 / N)*(ones(N) * ones(N)')) / sqrt(N - 1)
    W = zeros(N,N)
    T = zeros(N,N)

    P = ShallowWaters.Parameter(T=Float32;kwargs...)
    S_for_values = ShallowWaters.model_setup(P)

    nu = S_for_values.grid.nu
    nv = S_for_values.grid.nv
    nT = S_for_values.grid.nT

    S = zeros(length(data[:,1]), N)
    U = zeros(length(data[:,1]), N)

    # Generate the initial model realization ensemble,
    # generated by slightly perturbing the initial condition N times.
    # Output will be stored in the matrix Z, and all model structs will be
    # stored in S_all
    # We assume that Z is the total state vector in size, so 48896 is the
    # whole length of u + v + eta as a column vector
    Z = zeros(48896, N)
    S_all = []
    Progkf_all = []

    bred_vectors = compute_bred_vectors(N, sigma_initcond, uic, vic, etaic; kwargs...)

    for n = 1:N

        P_kf = ShallowWaters.Parameter(T=Float32;kwargs...)
        S_kf = ShallowWaters.model_setup(P_kf)

        S_kf.Prog.u = copy(uic)
        S_kf.Prog.v = copy(vic)
        S_kf.Prog.η = copy(etaic)

        P_kf = ShallowWaters.PrognosticVars{Float32}(ShallowWaters.remove_halo(S_kf.Prog.u,
            S_kf.Prog.v,
            S_kf.Prog.η,
            S_kf.Prog.sst,
            S_kf)...
        )

        # using bred vectors to perturb initial condition in each ensemble member
        P_kf.u = P_kf.u + reshape(bred_vectors[n][1:127*128], 127, 128)
        P_kf.v = P_kf.v + reshape(bred_vectors[n][(127*128+1):32512], 128, 127)
        P_kf.η = P_kf.η + reshape(bred_vectors[n][32513:end], 128, 128)

        # Z[:, n] = [vec(P_kf.u); vec(P_kf.v); vec(P_kf.η)]

        uic_new,vic_new,etaic_new = ShallowWaters.add_halo(P_kf.u,P_kf.v,P_kf.η,P_kf.sst,S_kf)

        S_kf.Prog.u = uic_new
        S_kf.Prog.v = vic_new
        S_kf.Prog.η = etaic_new

        Diag = S_kf.Diag
        Prog = S_kf.Prog
    
        @unpack u,v,η,sst = Prog
        @unpack u0,v0,η0 = Diag.RungeKutta
        @unpack u1,v1,η1 = Diag.RungeKutta
        @unpack du,dv,dη = Diag.Tendencies
        @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
        @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
    
        @unpack um,vm = Diag.SemiLagrange
    
        @unpack dynamics,RKo,RKs,tracer_advection = S_kf.parameters
        @unpack time_scheme,compensated = S_kf.parameters
        @unpack RKaΔt,RKbΔt = S_kf.constants
        @unpack Δt_Δ,Δt_Δs = S_kf.constants
    
        @unpack nt,dtint = S_kf.grid
        @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S_kf.grid
    
        # calculate layer thicknesses for initial conditions
        ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S_kf.forcing.H)
        ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
        ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
        ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)
    
        # calculate PV terms for initial conditions
        urhs = S.Diag.PrognosticVarsRHS.u .= S.Prog.u
        vrhs = S.Diag.PrognosticVarsRHS.v .= S.Prog.v
        ηrhs = S.Diag.PrognosticVarsRHS.η .= S.Prog.η
    
        ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S_kf)
        ShallowWaters.PVadvection!(Diag,S_kf)
    
        # propagate initial conditions
        copyto!(u0,u)
        copyto!(v0,v)
        copyto!(η0,η)
    
        # store initial conditions of sst for relaxation
        copyto!(Diag.SemiLagrange.sst_ref,sst)

        push!(S_all, S_kf)

    end

    for t = 1:S_for_values.grid.nt

        Progkf = []

        for n = 1:N

            p = one_step_function(S_all[n])
            push!(Progkf, p)

        end

        if t ∈ S_for_values.parameters.data_steps

            for k = 1:N

                Z[:, k] = [vec(Progkf[k].u); vec(Progkf[k].v); vec(Progkf[k].η)]
                U[:, k] = Z[Int.(data_spots), k]

            end

            d = data[:, S_for_values.parameters.j]
            E = (sigma_data .* randn(size(data[:,1])[1], N)) ./ sqrt(N-1)
            D = d * ones(N)' + sqrt(N - 1) .* E
            E = D * Π
            A = Z * Π
            Y = U * Π

            D̃ = D - U
            temp = Y*Y' + E*E'
            tempinv = (temp' * temp) * temp'
            W = Y'*(tempinv)*D̃

            Z = Z + A*W ./ (sqrt(N - 1))

            for k = 1:N

                Progkf[k].u .= reshape(Z[1:nu,k],S_for_values.grid.nux,S_for_values.grid.nuy)
                Progkf[k].v .= reshape(Z[nu+1:nv+nu,k],S_for_values.grid.nvx,S_for_values.grid.nvy)
                Progkf[k].η .= reshape(Z[nv+nu+1:nu+nv+nT,k],S_for_values.grid.nx,S_for_values.grid.ny)

                u,v,eta = ShallowWaters.add_halo(Progkf[k].u,
                    Progkf[k].v,
                    Progkf[k].η,
                    Progkf[k].sst,
                    S_all[k]
                )

                S_all[k].Prog.u = u
                S_all[k].Prog.v = v
                S_all[k].Prog.η = eta

            end

            S_for_values.parameters.j += 1

        end

        if t ∈ 10:10:S_for_values.grid.nt

            kf_avgu = zeros(127,128)
            kf_avgv = zeros(128,127)
            for n = 1:N
                kf_avgu = kf_avgu .+ Progkf[n].u
                kf_avgv = kf_avgv .+ Progkf[n].v
            end

            push!(ekf_avgu, (kf_avgu)./N)
            push!(ekf_avgv, (kf_avgv)./N)

        end

    end

    return S_all, ekf_avgu, ekf_avgv

end

function exp3_run_ensemble_kf(N, data, param_guess, data_spots, sigma_initcond, sigma_data;
    kwargs...
    )

     # save the average u and v values from the data assimilation
    ekf_avgu = []
    ekf_avgv = []

    uic = reshape(param_guess[1:17292], 131, 132)
    vic = reshape(param_guess[17293:34584], 132, 131)
    etaic = reshape(param_guess[34585:end-1], 130, 130)

    Π = (I - (1 / N)*(ones(N) * ones(N)')) / sqrt(N - 1)
    W = zeros(N,N)
    T = zeros(N,N)

    P = ShallowWaters.Parameter(T=Float32;kwargs...)
    S_for_values = ShallowWaters.model_setup(P)

    nu = S_for_values.grid.nu
    nv = S_for_values.grid.nv
    nT = S_for_values.grid.nT

    S = zeros(length(data[:,1]), N)
    U = zeros(length(data[:,1]), N)

    # Generate the initial model realization ensemble,
    # generated by slightly perturbing the initial condition N times.
    # Output will be stored in the matrix Z, and all model structs will be
    # stored in S_all
    # We assume that Z is the total state vector in size, so 48896 is the
    # whole length of u + v + eta as a column vector
    Z = zeros(48896+1, N)
    S_all = []
    Progkf_all = []

    bred_vectors = compute_bred_vectors(N, sigma_initcond, uic, vic, etaic; kwargs...)

    for n = 1:N

        P_kf = ShallowWaters.Parameter(T=Float32;kwargs...)
        P_kf.Fx0 = .0001 * P_kf.Fx0
        S_kf = ShallowWaters.model_setup(P_kf)

        S_kf.Prog.u = copy(uic)
        S_kf.Prog.v = copy(vic)
        S_kf.Prog.η = copy(etaic)

        P_kf = ShallowWaters.PrognosticVars{Float32}(ShallowWaters.remove_halo(S_kf.Prog.u,
            S_kf.Prog.v,
            S_kf.Prog.η,
            S_kf.Prog.sst,
            S_kf)...
        )

        # using bred vectors to perturb initial condition in each ensemble member
        P_kf.u = P_kf.u + reshape(bred_vectors[n][1:127*128], 127, 128)
        P_kf.v = P_kf.v + reshape(bred_vectors[n][(127*128+1):32512], 128, 127)
        P_kf.η = P_kf.η + reshape(bred_vectors[n][32513:end], 128, 128)

        uic_new,vic_new,etaic_new = ShallowWaters.add_halo(P_kf.u,P_kf.v,P_kf.η,P_kf.sst,S_kf)

        S_kf.Prog.u = uic_new
        S_kf.Prog.v = vic_new
        S_kf.Prog.η = etaic_new
        S_kf.parameters.Fx0 = S_kf.parameters.Fx0 + 0.0002 * randn(1)[1]

        Diag = S_kf.Diag
        Prog = S_kf.Prog
    
        @unpack u,v,η,sst = Prog
        @unpack u0,v0,η0 = Diag.RungeKutta
        @unpack u1,v1,η1 = Diag.RungeKutta
        @unpack du,dv,dη = Diag.Tendencies
        @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
        @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
    
        @unpack um,vm = Diag.SemiLagrange
    
        @unpack dynamics,RKo,RKs,tracer_advection = S_kf.parameters
        @unpack time_scheme,compensated = S_kf.parameters
        @unpack RKaΔt,RKbΔt = S_kf.constants
        @unpack Δt_Δ,Δt_Δs = S_kf.constants
    
        @unpack nt,dtint = S_kf.grid
        @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S_kf.grid
    
        # calculate layer thicknesses for initial conditions
        ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S_kf.forcing.H)
        ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
        ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
        ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)
    
        # calculate PV terms for initial conditions
        urhs = S.Diag.PrognosticVarsRHS.u .= S.Prog.u
        vrhs = S.Diag.PrognosticVarsRHS.v .= S.Prog.v
        ηrhs = S.Diag.PrognosticVarsRHS.η .= S.Prog.η
    
        ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S_kf)
        ShallowWaters.PVadvection!(Diag,S_kf)
    
        # propagate initial conditions
        copyto!(u0,u)
        copyto!(v0,v)
        copyto!(η0,η)
    
        # store initial conditions of sst for relaxation
        copyto!(Diag.SemiLagrange.sst_ref,sst)

        push!(S_all, S_kf)

    end

    for t = 1:S_for_values.grid.nt

        Progkf = []

        for n = 1:N

            p = one_step_function(S_all[n])
            push!(Progkf, p)

        end

        if t ∈ S_for_values.parameters.data_steps

            for k = 1:N

                Z[1:nu+nv+nT, k] = [vec(Progkf[k].u); vec(Progkf[k].v); vec(Progkf[k].η)]
                Z[end,k] = S_all[k].parameters.Fx0
                U[:, k] = Z[Int.(data_spots), k]

            end

            d = data[:, S_for_values.parameters.j]
            E = (sigma_data .* randn(size(data[:,1])[1], N)) ./ sqrt(N-1)
            D = d * ones(N)' + sqrt(N - 1) .* E
            E = D * Π
            A = Z * Π
            Y = U * Π

            D̃ = D - U
            temp = Y*Y' + E*E'
            tempinv = (temp' * temp) * temp'
            W = Y'*(tempinv)*D̃

            Z = Z + A*W ./ (sqrt(N - 1))

            for k = 1:N

                Progkf[k].u .= reshape(Z[1:nu,k],S_for_values.grid.nux,S_for_values.grid.nuy)
                Progkf[k].v .= reshape(Z[nu+1:nv+nu,k],S_for_values.grid.nvx,S_for_values.grid.nvy)
                Progkf[k].η .= reshape(Z[nv+nu+1:nu+nv+nT,k],S_for_values.grid.nx,S_for_values.grid.ny)

                u,v,eta = ShallowWaters.add_halo(Progkf[k].u,
                    Progkf[k].v,
                    Progkf[k].η,
                    Progkf[k].sst,
                    S_all[k]
                )

                S_all[k].Prog.u = u
                S_all[k].Prog.v = v
                S_all[k].Prog.η = eta
                S_all[k].parameters.Fx0 = Z[end,k]

            end

            S_for_values.parameters.j += 1

        end

        if t ∈ 10:10:S_for_values.grid.nt

            kf_avgu = zeros(127,128)
            kf_avgv = zeros(128,127)
            for n = 1:N
                kf_avgu = kf_avgu .+ Progkf[n].u
                kf_avgv = kf_avgv .+ Progkf[n].v
            end

            push!(ekf_avgu, (kf_avgu)./N)
            push!(ekf_avgv, (kf_avgv)./N)

        end

    end

    return S_all, ekf_avgu, ekf_avgv

end

function exp4_run_ensemble_kf(N, data, param_guess, data_spots, sigma_initcond, sigma_data, uic, vic, etaic;
    kwargs...
    )

    # save the average u and v values from the data assimilation
    ekf_avgu = []
    ekf_avgv = []

    Π = (I - (1 / N)*(ones(N) * ones(N)')) / sqrt(N - 1)
    W = zeros(N,N)
    T = zeros(N,N)

    P = ShallowWaters.Parameter(T=Float32;kwargs...)
    S_for_values = ShallowWaters.model_setup(P)

    nu = S_for_values.grid.nu
    nv = S_for_values.grid.nv
    nT = S_for_values.grid.nT

    S = zeros(length(data[:,1]), N)
    U = zeros(length(data[:,1]), N)

    # Generate the initial model realization ensemble,
    # generated by slightly perturbing the initial condition N times.
    # Output will be stored in the matrix Z, and all model structs will be
    # stored in S_all
    # We assume that Z is the total state vector in size, so 48896 is the
    # whole length of u + v + eta as a column vector
    Z = zeros(48896+1, N)
    S_all = []
    Progkf_all = []

    bred_vectors = compute_bred_vectors(N, sigma_initcond, uic, vic, etaic; kwargs...)

    for n = 1:N

        P_kf = ShallowWaters.Parameter(T=Float32;kwargs...)
        P_kf.Fx0 = .0001 * P_kf.Fx0
        S_kf = ShallowWaters.model_setup(P_kf)

        S_kf.Prog.u = copy(uic)
        S_kf.Prog.v = copy(vic)
        S_kf.Prog.η = copy(etaic)

        P_kf = ShallowWaters.PrognosticVars{Float32}(ShallowWaters.remove_halo(S_kf.Prog.u,
            S_kf.Prog.v,
            S_kf.Prog.η,
            S_kf.Prog.sst,
            S_kf)...
        )

        # using bred vectors to perturb initial condition in each ensemble member
        P_kf.u = P_kf.u + reshape(bred_vectors[n][1:127*128], 127, 128)
        P_kf.v = P_kf.v + reshape(bred_vectors[n][(127*128+1):32512], 128, 127)
        P_kf.η = P_kf.η + reshape(bred_vectors[n][32513:end], 128, 128)

        uic_new,vic_new,etaic_new = ShallowWaters.add_halo(P_kf.u,P_kf.v,P_kf.η,P_kf.sst,S_kf)

        S_kf.Prog.u = uic_new
        S_kf.Prog.v = vic_new
        S_kf.Prog.η = etaic_new
        S_kf.parameters.Fx0 = S_kf.parameters.Fx0 + 0.0005 * randn(1)[1]

        Diag = S_kf.Diag
        Prog = S_kf.Prog
    
        @unpack u,v,η,sst = Prog
        @unpack u0,v0,η0 = Diag.RungeKutta
        @unpack u1,v1,η1 = Diag.RungeKutta
        @unpack du,dv,dη = Diag.Tendencies
        @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
        @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
    
        @unpack um,vm = Diag.SemiLagrange
    
        @unpack dynamics,RKo,RKs,tracer_advection = S_kf.parameters
        @unpack time_scheme,compensated = S_kf.parameters
        @unpack RKaΔt,RKbΔt = S_kf.constants
        @unpack Δt_Δ,Δt_Δs = S_kf.constants
    
        @unpack nt,dtint = S_kf.grid
        @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S_kf.grid
    
        # calculate layer thicknesses for initial conditions
        ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S_kf.forcing.H)
        ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
        ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
        ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)
    
        # calculate PV terms for initial conditions
        urhs = S.Diag.PrognosticVarsRHS.u .= S.Prog.u
        vrhs = S.Diag.PrognosticVarsRHS.v .= S.Prog.v
        ηrhs = S.Diag.PrognosticVarsRHS.η .= S.Prog.η
    
        ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S_kf)
        ShallowWaters.PVadvection!(Diag,S_kf)
    
        # propagate initial conditions
        copyto!(u0,u)
        copyto!(v0,v)
        copyto!(η0,η)
    
        # store initial conditions of sst for relaxation
        copyto!(Diag.SemiLagrange.sst_ref,sst)

        push!(S_all, S_kf)

    end

    for t = 1:S_for_values.grid.nt

        Progkf = []

        for n = 1:N

            p = one_step_function(S_all[n])
            push!(Progkf, p)

        end

        if t ∈ S_for_values.parameters.data_steps

            for k = 1:N

                Z[1:(nu+nv+nT), k] = [vec(Progkf[k].u); vec(Progkf[k].v); vec(Progkf[k].η)]
                Z[end,k] = S_all[k].parameters.Fx0
                U[:, k] = Z[Int.(data_spots), k]

            end

            d = data[:, S_for_values.parameters.j]
            E = (sigma_data .* randn(size(data[:,1])[1], N)) ./ sqrt(N-1)
            D = d * ones(N)' + sqrt(N - 1) .* E
            E = D * Π
            A = Z * Π
            Y = U * Π

            D̃ = D - U
            temp = Y*Y' + E*E'
            tempinv = (temp' * temp) * temp'
            W = Y'*(tempinv)*D̃

            Z = Z + A*W ./ (sqrt(N - 1))

            for k = 1:N

                Progkf[k].u .= reshape(Z[1:nu,k],S_for_values.grid.nux,S_for_values.grid.nuy)
                Progkf[k].v .= reshape(Z[nu+1:nv+nu,k],S_for_values.grid.nvx,S_for_values.grid.nvy)
                Progkf[k].η .= reshape(Z[nv+nu+1:nu+nv+nT,k],S_for_values.grid.nx,S_for_values.grid.ny)

                u,v,eta = ShallowWaters.add_halo(Progkf[k].u,
                    Progkf[k].v,
                    Progkf[k].η,
                    Progkf[k].sst,
                    S_all[k]
                )

                S_all[k].Prog.u = u
                S_all[k].Prog.v = v
                S_all[k].Prog.η = eta
                S_all[k].parameters.Fx0 = Z[end,k]

            end

            S_for_values.parameters.j += 1

        end

        if t ∈ 10:10:S_for_values.grid.nt

            kf_avgu = zeros(127,128)
            kf_avgv = zeros(128,127)
            for n = 1:N
                kf_avgu = kf_avgu .+ Progkf[n].u
                kf_avgv = kf_avgv .+ Progkf[n].v
            end

            push!(ekf_avgu, (kf_avgu)./N)
            push!(ekf_avgv, (kf_avgv)./N)

        end

    end

    return S_all, ekf_avgu, ekf_avgv

end

"""
This function will create N (the number of ensembles) Bred vectors, which
will get used as the initial perturbations for the EKF
"""
function compute_bred_vectors(N, sigma_initcond, uic, vic, etaic; kwargs...)

    sigma_bv = 0.02

    bred_vectors = []

    for n = 1:N

        P = ShallowWaters.Parameter(T=Float32; kwargs...)
        S1 = ShallowWaters.model_setup(P)
        S2 = ShallowWaters.model_setup(P)

        # S1 will iterate the original unperturbed solution
        S1.Prog.u = copy(uic)
        S1.Prog.v = copy(vic)
        S1.Prog.η = copy(etaic)

        # S2 will iterate the perturbed solutions
        S2.Prog.u = copy(uic)
        S2.Prog.v = copy(vic)
        S2.Prog.η = copy(etaic)

        Prog = ShallowWaters.PrognosticVars{Float32}(ShallowWaters.remove_halo(S2.Prog.u,
            S2.Prog.v,
            S2.Prog.η,
            S2.Prog.sst,
            S2)...
        )

        # perturb initial conditions from the guessed value for each ensemble member
        upert = sigma_bv .* randn(size(Prog.u))
        vpert = sigma_bv .* randn(size(Prog.v))
        etapert = sigma_bv .* randn(size(Prog.η))

        # computing norms of the initial perturbations
        Au = norm(upert)
        Av = norm(vpert)
        Aeta = norm(etapert)

        # apply the perturbation to the initial condition
        Prog.u = Prog.u + upert
        Prog.v = Prog.v + vpert
        Prog.η = Prog.η + etapert

        upert,vpert,etapert = ShallowWaters.add_halo(Prog.u,Prog.v,Prog.η,Prog.sst,S2)

        # store this in S2
        S2.Prog.u = upert
        S2.Prog.v = vpert
        S2.Prog.η = etapert

        # Store the two initial models to be integrated
        S_all = []
        push!(S_all, S1)
        push!(S_all, S2)

        # code that appears before the time integration
        for S in S_all

            Diag = S.Diag
            Prog = S.Prog
        
            @unpack u,v,η,sst = Prog
            @unpack u0,v0,η0 = Diag.RungeKutta
            @unpack u1,v1,η1 = Diag.RungeKutta
            @unpack du,dv,dη = Diag.Tendencies
            @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
            @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
        
            @unpack um,vm = Diag.SemiLagrange
        
            @unpack dynamics,RKo,RKs,tracer_advection = S.parameters
            @unpack time_scheme,compensated = S.parameters
            @unpack RKaΔt,RKbΔt = S.constants
            @unpack Δt_Δ,Δt_Δs = S.constants
        
            @unpack nt,dtint = S.grid
            @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S.grid
        
            # calculate layer thicknesses for initial conditions
            ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S.forcing.H)
            ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
            ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
            ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)

            # calculate PV terms for initial conditions
            urhs = S.Diag.PrognosticVarsRHS.u .= S.Prog.u
            vrhs = S.Diag.PrognosticVarsRHS.v .= S.Prog.v
            ηrhs = S.Diag.PrognosticVarsRHS.η .= S.Prog.η
        
            ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S)
            ShallowWaters.PVadvection!(Diag,S)
        
            # propagate initial conditions
            copyto!(u0,u)
            copyto!(v0,v)
            copyto!(η0,η)
        
            # store initial conditions of sst for relaxation
            copyto!(Diag.SemiLagrange.sst_ref,sst)
        end

        # integrate and compute the Bred vector, roughly three days of integrating (a somewhat randomly chosen
        # amount of time)
        for t = 1:675

            # if we're at the final timestep then we want to store the bred vector
            if t === 675

                p1 = one_step_function(S_all[1])
                p2 = one_step_function(S_all[2])

                normu = norm(p2.u)
                normv = norm(p2.v)
                normeta = norm(p2.η)

                uperturbation = (p1.u - p2.u) * (Au / normu)
                vperturbation = (p1.v - p2.v) * (Av / normv)
                etaperturbation = (p1.η - p2.η) * (Aeta / normeta)

                push!(bred_vectors, [vec(uperturbation); vec(vperturbation); vec(etaperturbation)])

            else

                p1 = one_step_function(S_all[1])
                p2 = one_step_function(S_all[2])

                normu = norm(p2.u)
                normv = norm(p2.v)
                normeta = norm(p2.η)

                uperturbation = (p1.u - p2.u) * (Au / normu)
                vperturbation = (p1.v - p2.v) * (Av / normv)
                etaperturbation = (p1.η - p2.η) * (Aeta / normeta)

                Prog1 = ShallowWaters.PrognosticVars{Float32}(ShallowWaters.remove_halo(S_all[1].Prog.u,
                S_all[1].Prog.v,
                S_all[1].Prog.η,
                S_all[1].Prog.sst,
                S_all[1])...
                )

                Prog2 = ShallowWaters.PrognosticVars{Float32}(ShallowWaters.remove_halo(S_all[2].Prog.u,
                S_all[2].Prog.v,
                S_all[2].Prog.η,
                S_all[2].Prog.sst,
                S_all[2])...
                )

                Prog2.u = copy(Prog1.u) + uperturbation
                Prog2.v = copy(Prog1.v) + vperturbation
                Prog2.η = copy(Prog1.η) + etaperturbation

                uic,vic,etaic = ShallowWaters.add_halo(Prog2.u,Prog2.v,Prog2.η,Prog2.sst,S_all[2])

                S_all[2].Prog.u = uic
                S_all[2].Prog.v = vic
                S_all[2].Prog.η = etaic

            end

        end

    end

    return bred_vectors

end