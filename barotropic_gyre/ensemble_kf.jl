# We need a version of the integration function that runs a single timestep and 
# takes as input the current prognostic fields. This function will then be
# passed to Enzyme for computing the Jacobian, which can subsequently be used
# in the Kalman filter. We're giving as input uveta, which will be a block
# vector of the fields u, v, and eta in that order. The restructuring of the
# arrays will be as columns stacked on top of eachother, e.g. the first column becomes
# the first bit of the vector, the second column the second bit, and so on.

using Parameters
# Enzyme.API.looseTypeAnalysis!(true)

"""
This function will run the ensemble Kalman filter. It needs to be given:
    model - this will contain all the information needed for the ensemble run
    param_guess - the guess at what the initial condition is
"""
function run_ensemble_kf(model, param_guess; udata=false,vdata=false,etadata=false)

    N = model.N
    data = model.data
    data_steps = model.data_steps
    data_spots = model.data_spots
    sigma_initcond = model.sigma_initcond
    sigma_data = model.sigma_data
    j = model.j

    # save the average u, v, and eta values from the data assimilation
    ekf_avgu = []
    ekf_avgv = []
    ekf_avgeta = []

    uic = model.S.parameters.T.(zeros(model.S.grid.nux,model.S.grid.nuy))
    vic = model.S.parameters.T.(zeros(model.S.grid.nvx,model.S.grid.nvy))
    etaic = model.S.parameters.T.(zeros(model.S.grid.nx,model.S.grid.ny))
    current = 1
    for m in (uic, vic, etaic)
        sz = prod(size(m))
        m .= reshape(param_guess[current:(current + sz - 1)], size(m)...)
        current += sz
    end

    Π = (I - (1 / N)*(ones(N) * ones(N)')) / sqrt(N - 1)
    W = zeros(N,N)
    T = zeros(N,N)

    S_for_values = deepcopy(model.S)

    nu = S_for_values.grid.nu
    nv = S_for_values.grid.nv
    nT = S_for_values.grid.nT

    S = zeros(length(data_spots), N)
    U = zeros(length(data_spots), N)

    # Generate the initial model realization ensemble,
    # generated by slightly perturbing the initial condition N times.
    # Output will be stored in the matrix Z, and all model structs will be
    # stored in S_all
    # We assume that Z is the total state vector in size, so 48896 is the
    # whole length of u + v + eta as a column vector
    Z = zeros(model.S.grid.nu + model.S.grid.nv + model.S.grid.nT, N)
    S_all = []

    bred_vectors = compute_bred_vectors(N,sigma_initcond,uic,vic,etaic,model.S.parameters)

    for n = 1:N

        S_kf = deepcopy(model.S)

        #only keeping this so I have an sst field without a halo for later step
        P_kf = ShallowWaters.PrognosticVars{S_kf.parameters.Tprog}(ShallowWaters.remove_halo(S_kf.Prog.u,
            S_kf.Prog.v,
            S_kf.Prog.η,
            S_kf.Prog.sst,
            S_kf)...
        )

        # using bred vectors to perturb initial condition in each ensemble member
        uic = uic + reshape(bred_vectors[n][1:model.S.grid.nu], model.S.grid.nux, model.S.grid.nuy)
        vic = vic + reshape(bred_vectors[n][(model.S.grid.nu+1):(model.S.grid.nu+model.S.grid.nv)], model.S.grid.nvx, model.S.grid.nvy)
        etaic = etaic + reshape(bred_vectors[n][(model.S.grid.nu+model.S.grid.nv+1):end], model.S.grid.nx, model.S.grid.ny)

        # Z[:, n] = [vec(P_kf.u); vec(P_kf.v); vec(P_kf.η)]

        uic_new,vic_new,etaic_new = ShallowWaters.add_halo(uic,vic,etaic,P_kf.sst,S_kf)

        S_kf.Prog.u = uic_new
        S_kf.Prog.v = vic_new
        S_kf.Prog.η = etaic_new

        Diag = S_kf.Diag
        Prog = S_kf.Prog

        # for each ensemble member we want to do the steps that occur before the integration
        @unpack u,v,η,sst = Prog
        @unpack u0,v0,η0 = Diag.RungeKutta
        @unpack u1,v1,η1 = Diag.RungeKutta
        @unpack du,dv,dη = Diag.Tendencies
        @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
        @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
    
        @unpack um,vm = Diag.SemiLagrange
    
        @unpack dynamics,RKo,RKs,tracer_advection = S_kf.parameters
        @unpack time_scheme,compensated = S_kf.parameters
        @unpack RKaΔt,RKbΔt = S_kf.constants
        @unpack Δt_Δ,Δt_Δs = S_kf.constants
    
        @unpack nt,dtint = S_kf.grid
        @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S_kf.grid
    
        # calculate layer thicknesses for initial conditions
        ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S_kf.forcing.H)
        ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
        ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
        ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)
    
        # calculate PV terms for initial conditions
        urhs = S_kf.Diag.PrognosticVarsRHS.u .= S_kf.Prog.u
        vrhs = S_kf.Diag.PrognosticVarsRHS.v .= S_kf.Prog.v
        ηrhs = S_kf.Diag.PrognosticVarsRHS.η .= S_kf.Prog.η
    
        ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S_kf)
        ShallowWaters.PVadvection!(Diag,S_kf)
    
        # propagate initial conditions
        copyto!(u0,u)
        copyto!(v0,v)
        copyto!(η0,η)
    
        # store initial conditions of sst for relaxation
        copyto!(Diag.SemiLagrange.sst_ref,sst)

        # store all of the ensemble models
        push!(S_all, S_kf)

    end

    for i = 1:S_for_values.grid.nt

        Progkf = []

        for n = 1:N

            p = one_step_function(S_all[n], i)
            push!(Progkf, p)

        end

        if i ∈ data_steps
            for k = 1:N

                Z[:, k] = [vec(Progkf[k].u); vec(Progkf[k].v); vec(Progkf[k].η)]

                if udata || udata && vdata || udata && vdata && etadata
                    U[:, k] = Z[Int.(data_spots), k]
                elseif vdata
                    U[:, k] = Z[Int.(data_spots) .+ 128*127, k]
                else etadata
                    U[:, k] = Z[Int.(data_spots) .+ 2*127*128, k]
                end

            end

            E_fixed = (sigma_data .* randn(length(data_spots), N)) ./ sqrt(N-1)
            d = data[:, j][data_spots]
            D = d * ones(N)' + sqrt(N - 1) .* E_fixed
            E = D * Π
            A = Z * Π
            Y = U * Π

            D̃ = D - U
            temp = Y*Y' + E*E'
            tempinv = temp^(-1)
            # tempinv = (temp' * temp) * temp'
            W = Y'*(tempinv)*D̃

            Z += A*W ./ (sqrt(N - 1))

            if any(isnan, Z)
                error("Ensemble array contains NaN values")
            end

            for k = 1:N

                Progkf[k].u .= reshape(Z[1:nu,k],S_for_values.grid.nux,S_for_values.grid.nuy)
                Progkf[k].v .= reshape(Z[nu+1:nv+nu,k],S_for_values.grid.nvx,S_for_values.grid.nvy)
                Progkf[k].η .= reshape(Z[nv+nu+1:nu+nv+nT,k],S_for_values.grid.nx,S_for_values.grid.ny)

                u,v,eta = ShallowWaters.add_halo(Progkf[k].u,
                    Progkf[k].v,
                    Progkf[k].η,
                    Progkf[k].sst,
                    S_all[k]
                )

                S_all[k].Prog.u = u
                S_all[k].Prog.v = v
                S_all[k].Prog.η = eta

            end

            j += 1

        end

        # storing hourly data points
        if i ∈ 9:9:S_for_values.grid.nt

            kf_avgu = zeros(model.S.grid.nux,model.S.grid.nuy)
            kf_avgv = zeros(model.S.grid.nvx,model.S.grid.nvy)
            kf_avgeta = zeros(model.S.grid.nx,model.S.grid.ny)
            for n = 1:N
                kf_avgu = kf_avgu .+ Progkf[n].u
                kf_avgv = kf_avgv .+ Progkf[n].v
                kf_avgeta = kf_avgeta .+ Progkf[n].η
            end

            push!(ekf_avgu, (kf_avgu)./N)
            push!(ekf_avgv, (kf_avgv)./N)
            push!(ekf_avgeta, (kf_avgeta)./N)

        end

    end

    return ekf_avgu, ekf_avgv, ekf_avgeta

end

function windstress_ensemble_kf(model, param_guess; udata=false,vdata=false,etadata=false)

    N = model.N
    data = model.data
    data_steps = model.data_steps
    data_spots = model.data_spots
    sigma_initcond = model.sigma_initcond
    sigma_data = model.sigma_data
    j = model.j

    # save the average u, v, and eta values from the data assimilation
    ekf_avgu = []
    ekf_avgv = []
    ekf_avgeta = []

    uic = model.S.parameters.T.(zeros(model.S.grid.nux,model.S.grid.nuy))
    vic = model.S.parameters.T.(zeros(model.S.grid.nvx,model.S.grid.nvy))
    etaic = model.S.parameters.T.(zeros(model.S.grid.nx,model.S.grid.ny))
    current = 1
    for m in (uic, vic, etaic)
        sz = prod(size(m))
        m .= reshape(param_guess[current:(current + sz - 1)], size(m)...)
        current += sz
    end

    Π = (I - (1 / N)*(ones(N) * ones(N)')) / sqrt(N - 1)
    E_fixed = (sigma_data .* randn(length(data_spots), N)) ./ sqrt(N-1)
    W = zeros(N,N)
    T = zeros(N,N)

    S_for_values = deepcopy(model.S)

    nu = S_for_values.grid.nu
    nv = S_for_values.grid.nv
    nT = S_for_values.grid.nT

    S = zeros(length(data_spots), N)
    U = zeros(length(data_spots), N)

    # Generate the initial model realization ensemble,
    # generated by slightly perturbing the initial condition N times.
    # Output will be stored in the matrix Z, and all model structs will be
    # stored in S_all
    # For the wind-stress experiment we're going to see the extent to which the EKF
    # can improve the perturbed (incorrect) wind-stress field, so the Fx field is added to
    # the columns in Z
    Z = zeros(model.S.grid.nu + model.S.grid.nv + model.S.grid.nT + 1, N)
    S_all = []

    bred_vectors = compute_bred_vectors(N,sigma_initcond,uic,vic,etaic,model.S.parameters)

    for n = 1:N

        S_kf = deepcopy(model.S)

        #only keeping this so I have an sst field without a halo for later step
        P_kf = ShallowWaters.PrognosticVars{S_kf.parameters.Tprog}(ShallowWaters.remove_halo(S_kf.Prog.u,
            S_kf.Prog.v,
            S_kf.Prog.η,
            S_kf.Prog.sst,
            S_kf)...
        )

        # using bred vectors to perturb initial condition in each ensemble member
        uic = uic + reshape(bred_vectors[n][1:model.S.grid.nu], model.S.grid.nux, model.S.grid.nuy)
        vic = vic + reshape(bred_vectors[n][(model.S.grid.nu+1):(model.S.grid.nu+model.S.grid.nv)], model.S.grid.nvx, model.S.grid.nvy)
        etaic = etaic + reshape(bred_vectors[n][(model.S.grid.nu+model.S.grid.nv+1):end], model.S.grid.nx, model.S.grid.ny)

        # Z[:, n] = [vec(P_kf.u); vec(P_kf.v); vec(P_kf.η)]

        uic_new,vic_new,etaic_new = ShallowWaters.add_halo(uic,vic,etaic,P_kf.sst,S_kf)

        S_kf.Prog.u = uic_new
        S_kf.Prog.v = vic_new
        S_kf.Prog.η = etaic_new

        # perturbing the wind stress forcing amplitude
        S_kf.parameters.Fx0 = model.pred_forcing + randn(1)[1] * model.sigma_forcing

        Diag = S_kf.Diag
        Prog = S_kf.Prog

        # for each ensemble member we want to do the steps that occur before the integration
        @unpack u,v,η,sst = Prog
        @unpack u0,v0,η0 = Diag.RungeKutta
        @unpack u1,v1,η1 = Diag.RungeKutta
        @unpack du,dv,dη = Diag.Tendencies
        @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
        @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
    
        @unpack um,vm = Diag.SemiLagrange
    
        @unpack dynamics,RKo,RKs,tracer_advection = S_kf.parameters
        @unpack time_scheme,compensated = S_kf.parameters
        @unpack RKaΔt,RKbΔt = S_kf.constants
        @unpack Δt_Δ,Δt_Δs = S_kf.constants
    
        @unpack nt,dtint = S_kf.grid
        @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S_kf.grid
    
        # calculate layer thicknesses for initial conditions
        ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S_kf.forcing.H)
        ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
        ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
        ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)
    
        # calculate PV terms for initial conditions
        urhs = S_kf.Diag.PrognosticVarsRHS.u .= S_kf.Prog.u
        vrhs = S_kf.Diag.PrognosticVarsRHS.v .= S_kf.Prog.v
        ηrhs = S_kf.Diag.PrognosticVarsRHS.η .= S_kf.Prog.η
    
        ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S_kf)
        ShallowWaters.PVadvection!(Diag,S_kf)
    
        # propagate initial conditions
        copyto!(u0,u)
        copyto!(v0,v)
        copyto!(η0,η)
    
        # store initial conditions of sst for relaxation
        copyto!(Diag.SemiLagrange.sst_ref,sst)

        # store all of the ensemble models
        push!(S_all, S_kf)

    end

    for i = 1:S_for_values.grid.nt

        Progkf = []

        for n = 1:N

            p = one_step_function(S_all[n], i)
            push!(Progkf, p)

        end

        if i ∈ data_steps
            for k = 1:N

                Z[:, k] = [vec(Progkf[k].u); vec(Progkf[k].v); vec(Progkf[k].η); S_all[k].parameters.Fx0]

                if udata || udata && vdata || udata && vdata && etadata
                    U[:, k] = Z[Int.(data_spots), k]
                elseif vdata
                    U[:, k] = Z[Int.(data_spots) .+ 128*127, k]
                else etadata
                    U[:, k] = Z[Int.(data_spots) .+ 2*127*128, k]
                end

            end

            d = data[:, j][data_spots]
            D = d * ones(N)' + sqrt(N - 1) .* E_fixed
            E = D * Π
            A = Z * Π
            Y = U * Π

            D̃ = D - U
            temp = Y*Y' + E*E'
            tempinv = (temp' * temp) * temp'
            W = Y'*(tempinv)*D̃

            Z += A*W ./ (sqrt(N - 1))

            if any(isnan, Z)
                error("Ensemble array contains NaN values")
            end

            for k = 1:N

                Progkf[k].u .= reshape(Z[1:nu,k],S_for_values.grid.nux,S_for_values.grid.nuy)
                Progkf[k].v .= reshape(Z[nu+1:nv+nu,k],S_for_values.grid.nvx,S_for_values.grid.nvy)
                Progkf[k].η .= reshape(Z[nv+nu+1:nu+nv+nT,k],S_for_values.grid.nx,S_for_values.grid.ny)

                u,v,eta = ShallowWaters.add_halo(Progkf[k].u,
                    Progkf[k].v,
                    Progkf[k].η,
                    Progkf[k].sst,
                    S_all[k]
                )

                S_all[k].Prog.u = u
                S_all[k].Prog.v = v
                S_all[k].Prog.η = eta
                S_all[k].parameters.Fx0 = Z[end, k]

            end

            j += 1

        end

        # storing hourly data points
        if i ∈ 9:9:S_for_values.grid.nt

            kf_avgu = zeros(model.S.grid.nux,model.S.grid.nuy)
            kf_avgv = zeros(model.S.grid.nvx,model.S.grid.nvy)
            kf_avgeta = zeros(model.S.grid.nx,model.S.grid.ny)
            for n = 1:N
                kf_avgu = kf_avgu .+ Progkf[n].u
                kf_avgv = kf_avgv .+ Progkf[n].v
                kf_avgeta = kf_avgeta .+ Progkf[n].η
            end

            push!(ekf_avgu, (kf_avgu)./N)
            push!(ekf_avgv, (kf_avgv)./N)
            push!(ekf_avgeta, (kf_avgeta)./N)

        end

    end

    return ekf_avgu, ekf_avgv, ekf_avgeta

end

function bottomdrag_ensemble_kf(model, param_guess; udata=false,vdata=false,etadata=false)

    N = model.N
    data = model.data
    data_steps = model.data_steps
    data_spots = model.data_spots
    sigma_initcond = model.sigma_initcond
    sigma_data = model.sigma_data
    j = model.j

    # save the average u, v, and eta values from the data assimilation
    ekf_avgu = []
    ekf_avgv = []
    ekf_avgeta = []

    uic = model.S.parameters.T.(zeros(model.S.grid.nux,model.S.grid.nuy))
    vic = model.S.parameters.T.(zeros(model.S.grid.nvx,model.S.grid.nvy))
    etaic = model.S.parameters.T.(zeros(model.S.grid.nx,model.S.grid.ny))
    current = 1
    for m in (uic, vic, etaic)
        sz = prod(size(m))
        m .= reshape(param_guess[current:(current + sz - 1)], size(m)...)
        current += sz
    end

    Π = (I - (1 / N)*(ones(N) * ones(N)')) / sqrt(N - 1)
    W = zeros(N,N)
    T = zeros(N,N)

    S_for_values = deepcopy(model.S)

    nu = S_for_values.grid.nu
    nv = S_for_values.grid.nv
    nT = S_for_values.grid.nT

    S = zeros(length(data_spots), N)
    U = zeros(length(data_spots), N)

    # Generate the initial model realization ensemble,
    # generated by slightly perturbing the initial condition N times.
    # Output will be stored in the matrix Z, and all model structs will be
    # stored in S_all
    # For the wind-stress experiment we're going to see the extent to which the EKF
    # can improve the perturbed (incorrect) wind-stress field, so the Fx field is added to
    # the columns in Z
    Z = zeros(model.S.grid.nu + model.S.grid.nv + model.S.grid.nT, N)
    S_all = []

    bred_vectors = compute_bred_vectors(N,sigma_initcond,uic,vic,etaic,model.S.parameters)

    for n = 1:N

        S_kf = deepcopy(model.S)

        #only keeping this so I have an sst field without a halo for later step
        P_kf = ShallowWaters.PrognosticVars{S_kf.parameters.Tprog}(ShallowWaters.remove_halo(S_kf.Prog.u,
            S_kf.Prog.v,
            S_kf.Prog.η,
            S_kf.Prog.sst,
            S_kf)...
        )

        # using bred vectors to perturb initial condition in each ensemble member
        uic = uic + reshape(bred_vectors[n][1:model.S.grid.nu], model.S.grid.nux, model.S.grid.nuy)
        vic = vic + reshape(bred_vectors[n][(model.S.grid.nu+1):(model.S.grid.nu+model.S.grid.nv)], model.S.grid.nvx, model.S.grid.nvy)
        etaic = etaic + reshape(bred_vectors[n][(model.S.grid.nu+model.S.grid.nv+1):end], model.S.grid.nx, model.S.grid.ny)

        # Z[:, n] = [vec(P_kf.u); vec(P_kf.v); vec(P_kf.η)]

        uic_new,vic_new,etaic_new = ShallowWaters.add_halo(uic,vic,etaic,P_kf.sst,S_kf)

        S_kf.Prog.u = uic_new
        S_kf.Prog.v = vic_new
        S_kf.Prog.η = etaic_new

        Diag = S_kf.Diag
        Prog = S_kf.Prog

        # for each ensemble member we want to do the steps that occur before the integration
        @unpack u,v,η,sst = Prog
        @unpack u0,v0,η0 = Diag.RungeKutta
        @unpack u1,v1,η1 = Diag.RungeKutta
        @unpack du,dv,dη = Diag.Tendencies
        @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
        @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
    
        @unpack um,vm = Diag.SemiLagrange
    
        @unpack dynamics,RKo,RKs,tracer_advection = S_kf.parameters
        @unpack time_scheme,compensated = S_kf.parameters
        @unpack RKaΔt,RKbΔt = S_kf.constants
        @unpack Δt_Δ,Δt_Δs = S_kf.constants
    
        @unpack nt,dtint = S_kf.grid
        @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S_kf.grid
    
        # calculate layer thicknesses for initial conditions
        ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S_kf.forcing.H)
        ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
        ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
        ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)
    
        # calculate PV terms for initial conditions
        urhs = S_kf.Diag.PrognosticVarsRHS.u .= S_kf.Prog.u
        vrhs = S_kf.Diag.PrognosticVarsRHS.v .= S_kf.Prog.v
        ηrhs = S_kf.Diag.PrognosticVarsRHS.η .= S_kf.Prog.η
    
        ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S_kf)
        ShallowWaters.PVadvection!(Diag,S_kf)
    
        # propagate initial conditions
        copyto!(u0,u)
        copyto!(v0,v)
        copyto!(η0,η)
    
        # store initial conditions of sst for relaxation
        copyto!(Diag.SemiLagrange.sst_ref,sst)

        # store all of the ensemble models
        push!(S_all, S_kf)

    end

    for i = 1:S_for_values.grid.nt

        Progkf = []

        for n = 1:N

            p = one_step_function(S_all[n], i)
            push!(Progkf, p)

        end

        if i ∈ data_steps

            for k = 1:N

                Z[:, k] = [vec(Progkf[k].u); vec(Progkf[k].v); vec(Progkf[k].η)]

                if udata || udata && vdata || udata && vdata && etadata
                    U[:, k] = Z[Int.(data_spots), k]
                elseif vdata
                    U[:, k] = Z[Int.(data_spots) .+ 128*127, k]
                else etadata
                    U[:, k] = Z[Int.(data_spots) .+ 2*127*128, k]
                end

            end

            d = data[:, j][data_spots]
            E = (sigma_data .* randn(length(data_spots), N)) ./ sqrt(N-1)
            D = d * ones(N)' + sqrt(N - 1) .* E
            E = D * Π
            A = Z * Π
            Y = U * Π

            D̃ = D - U
            temp = Y*Y' + E*E'
            tempinv = (temp' * temp) * temp'
            W = Y'*(tempinv)*D̃

            Z = Z + A*W ./ (sqrt(N - 1))

            for k = 1:N

                Progkf[k].u .= reshape(Z[1:nu,k],S_for_values.grid.nux,S_for_values.grid.nuy)
                Progkf[k].v .= reshape(Z[nu+1:nv+nu,k],S_for_values.grid.nvx,S_for_values.grid.nvy)
                Progkf[k].η .= reshape(Z[nv+nu+1:nu+nv+nT,k],S_for_values.grid.nx,S_for_values.grid.ny)

                u,v,eta = ShallowWaters.add_halo(Progkf[k].u,
                    Progkf[k].v,
                    Progkf[k].η,
                    Progkf[k].sst,
                    S_all[k]
                )

                S_all[k].Prog.u = u
                S_all[k].Prog.v = v
                S_all[k].Prog.η = eta

            end

            j += 1

        end

        # storing hourly data points
        if i ∈ 9:9:S_for_values.grid.nt

            kf_avgu = zeros(model.S.grid.nux,model.S.grid.nuy)
            kf_avgv = zeros(model.S.grid.nvx,model.S.grid.nvy)
            kf_avgeta = zeros(model.S.grid.nx,model.S.grid.ny)
            for n = 1:N
                kf_avgu = kf_avgu .+ Progkf[n].u
                kf_avgv = kf_avgv .+ Progkf[n].v
                kf_avgeta = kf_avgeta .+ Progkf[n].η
            end

            push!(ekf_avgu, (kf_avgu)./N)
            push!(ekf_avgv, (kf_avgv)./N)
            push!(ekf_avgeta, (kf_avgeta)./N)

        end

    end

    return ekf_avgu, ekf_avgv, ekf_avgeta

end

function exp3_run_ensemble_kf(model, param_guess)

    N = model.N
    data = model.data
    data_steps = model.data_steps
    data_spots = model.data_spots
    sigma_initcond = model.sigma_initcond
    sigma_data = model.sigma_data
    j = model.j

    # save the average u and v values from the data assimilation
    ekf_avgu = []
    ekf_avgv = []

    uic = reshape(param_guess[1:17292], 131, 132)
    vic = reshape(param_guess[17293:34584], 132, 131)
    etaic = reshape(param_guess[34585:end-1], 130, 130)

    Π = (I - (1 / N)*(ones(N) * ones(N)')) / sqrt(N - 1)
    W = zeros(N,N)
    T = zeros(N,N)

    S_for_values = deepcopy(model.S)

    nu = S_for_values.grid.nu
    nv = S_for_values.grid.nv
    nT = S_for_values.grid.nT

    S = zeros(length(data[:,1]), N)
    U = zeros(length(data[:,1]), N)

    # Generate the initial model realization ensemble,
    # generated by slightly perturbing the initial condition N times.
    # Output will be stored in the matrix Z, and all model structs will be
    # stored in S_all
    # We assume that Z is the total state vector in size, so 48896 is the
    # whole length of u + v + eta as a column vector
    Z = zeros(48896+1, N)
    S_all = []
    Progkf_all = []

    bred_vectors = compute_bred_vectors(N, sigma_initcond, uic, vic, etaic, model.S.parameters)

    for n = 1:N

        S_kf = deepcopy(model.S)
        S_kf.parameters.Fx0 = .0001 * S_kf.parameters.Fx0

        S_kf.Prog.u = copy(uic)
        S_kf.Prog.v = copy(vic)
        S_kf.Prog.η = copy(etaic)

        P_kf = ShallowWaters.PrognosticVars{S_kf.parameters.Tprog}(ShallowWaters.remove_halo(S_kf.Prog.u,
            S_kf.Prog.v,
            S_kf.Prog.η,
            S_kf.Prog.sst,
            S_kf)...
        )

        # using bred vectors to perturb initial condition in each ensemble member
        P_kf.u = P_kf.u + reshape(bred_vectors[n][1:127*128], 127, 128)
        P_kf.v = P_kf.v + reshape(bred_vectors[n][(127*128+1):32512], 128, 127)
        P_kf.η = P_kf.η + reshape(bred_vectors[n][32513:end], 128, 128)

        uic_new,vic_new,etaic_new = ShallowWaters.add_halo(P_kf.u,P_kf.v,P_kf.η,P_kf.sst,S_kf)

        S_kf.Prog.u = uic_new
        S_kf.Prog.v = vic_new
        S_kf.Prog.η = etaic_new
        S_kf.parameters.Fx0 = S_kf.parameters.Fx0 + 0.0002 * randn(1)[1]

        Diag = S_kf.Diag
        Prog = S_kf.Prog
    
        @unpack u,v,η,sst = Prog
        @unpack u0,v0,η0 = Diag.RungeKutta
        @unpack u1,v1,η1 = Diag.RungeKutta
        @unpack du,dv,dη = Diag.Tendencies
        @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
        @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
    
        @unpack um,vm = Diag.SemiLagrange
    
        @unpack dynamics,RKo,RKs,tracer_advection = S_kf.parameters
        @unpack time_scheme,compensated = S_kf.parameters
        @unpack RKaΔt,RKbΔt = S_kf.constants
        @unpack Δt_Δ,Δt_Δs = S_kf.constants
    
        @unpack nt,dtint = S_kf.grid
        @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S_kf.grid
    
        # calculate layer thicknesses for initial conditions
        ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S_kf.forcing.H)
        ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
        ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
        ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)
    
        # calculate PV terms for initial conditions
        urhs = S_kf.Diag.PrognosticVarsRHS.u .= S_kf.Prog.u
        vrhs = S_kf.Diag.PrognosticVarsRHS.v .= S_kf.Prog.v
        ηrhs = S_kf.Diag.PrognosticVarsRHS.η .= S_kf.Prog.η
    
        ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S_kf)
        ShallowWaters.PVadvection!(Diag,S_kf)
    
        # propagate initial conditions
        copyto!(u0,u)
        copyto!(v0,v)
        copyto!(η0,η)
    
        # store initial conditions of sst for relaxation
        copyto!(Diag.SemiLagrange.sst_ref,sst)

        push!(S_all, S_kf)

    end

    for t = 1:S_for_values.grid.nt

        Progkf = []

        for n = 1:N

            p = one_step_function(S_all[n])
            push!(Progkf, p)

        end

        if t ∈ S_for_values.parameters.data_steps

            for k = 1:N

                Z[1:nu+nv+nT, k] = [vec(Progkf[k].u); vec(Progkf[k].v); vec(Progkf[k].η)]
                Z[end,k] = S_all[k].parameters.Fx0
                U[:, k] = Z[Int.(data_spots), k]

            end

            d = data[:, S_for_values.parameters.j]
            E = (sigma_data .* randn(size(data[:,1])[1], N)) ./ sqrt(N-1)
            D = d * ones(N)' + sqrt(N - 1) .* E
            E = D * Π
            A = Z * Π
            Y = U * Π

            D̃ = D - U
            temp = Y*Y' + E*E'
            tempinv = (temp' * temp) * temp'
            W = Y'*(tempinv)*D̃

            Z = Z + A*W ./ (sqrt(N - 1))

            for k = 1:N

                Progkf[k].u .= reshape(Z[1:nu,k],S_for_values.grid.nux,S_for_values.grid.nuy)
                Progkf[k].v .= reshape(Z[nu+1:nv+nu,k],S_for_values.grid.nvx,S_for_values.grid.nvy)
                Progkf[k].η .= reshape(Z[nv+nu+1:nu+nv+nT,k],S_for_values.grid.nx,S_for_values.grid.ny)

                u,v,eta = ShallowWaters.add_halo(Progkf[k].u,
                    Progkf[k].v,
                    Progkf[k].η,
                    Progkf[k].sst,
                    S_all[k]
                )

                S_all[k].Prog.u = u
                S_all[k].Prog.v = v
                S_all[k].Prog.η = eta
                S_all[k].parameters.Fx0 = Z[end,k]

            end

            S_for_values.parameters.j += 1

        end

        if t ∈ 10:10:S_for_values.grid.nt

            kf_avgu = zeros(127,128)
            kf_avgv = zeros(128,127)
            for n = 1:N
                kf_avgu = kf_avgu .+ Progkf[n].u
                kf_avgv = kf_avgv .+ Progkf[n].v
            end

            push!(ekf_avgu, (kf_avgu)./N)
            push!(ekf_avgv, (kf_avgv)./N)

        end

    end

    return S_all, ekf_avgu, ekf_avgv

end

function exp4_run_ensemble_kf(N, data, param_guess, data_spots, sigma_initcond, sigma_data, uic, vic, etaic;
    kwargs...
    )

    # save the average u and v values from the data assimilation
    ekf_avgu = []
    ekf_avgv = []

    Π = (I - (1 / N)*(ones(N) * ones(N)')) / sqrt(N - 1)
    W = zeros(N,N)
    T = zeros(N,N)

    P = ShallowWaters.Parameter(T=Float32;kwargs...)
    S_for_values = ShallowWaters.model_setup(P)

    nu = S_for_values.grid.nu
    nv = S_for_values.grid.nv
    nT = S_for_values.grid.nT

    S = zeros(length(data[:,1]), N)
    U = zeros(length(data[:,1]), N)

    # Generate the initial model realization ensemble,
    # generated by slightly perturbing the initial condition N times.
    # Output will be stored in the matrix Z, and all model structs will be
    # stored in S_all
    # We assume that Z is the total state vector in size, so 48896 is the
    # whole length of u + v + eta as a column vector
    Z = zeros(48896+1, N)
    S_all = []
    Progkf_all = []

    bred_vectors = compute_bred_vectors(N, sigma_initcond, uic, vic, etaic; kwargs...)

    for n = 1:N

        P_kf = ShallowWaters.Parameter(T=Float32;kwargs...)
        P_kf.Fx0 = .0001 * P_kf.Fx0
        S_kf = ShallowWaters.model_setup(P_kf)

        S_kf.Prog.u = copy(uic)
        S_kf.Prog.v = copy(vic)
        S_kf.Prog.η = copy(etaic)

        P_kf = ShallowWaters.PrognosticVars{Float32}(ShallowWaters.remove_halo(S_kf.Prog.u,
            S_kf.Prog.v,
            S_kf.Prog.η,
            S_kf.Prog.sst,
            S_kf)...
        )

        # using bred vectors to perturb initial condition in each ensemble member
        P_kf.u = P_kf.u + reshape(bred_vectors[n][1:127*128], 127, 128)
        P_kf.v = P_kf.v + reshape(bred_vectors[n][(127*128+1):32512], 128, 127)
        P_kf.η = P_kf.η + reshape(bred_vectors[n][32513:end], 128, 128)

        uic_new,vic_new,etaic_new = ShallowWaters.add_halo(P_kf.u,P_kf.v,P_kf.η,P_kf.sst,S_kf)

        S_kf.Prog.u = uic_new
        S_kf.Prog.v = vic_new
        S_kf.Prog.η = etaic_new
        S_kf.parameters.Fx0 = S_kf.parameters.Fx0 + 0.0005 * randn(1)[1]

        Diag = S_kf.Diag
        Prog = S_kf.Prog
    
        @unpack u,v,η,sst = Prog
        @unpack u0,v0,η0 = Diag.RungeKutta
        @unpack u1,v1,η1 = Diag.RungeKutta
        @unpack du,dv,dη = Diag.Tendencies
        @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
        @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
    
        @unpack um,vm = Diag.SemiLagrange
    
        @unpack dynamics,RKo,RKs,tracer_advection = S_kf.parameters
        @unpack time_scheme,compensated = S_kf.parameters
        @unpack RKaΔt,RKbΔt = S_kf.constants
        @unpack Δt_Δ,Δt_Δs = S_kf.constants
    
        @unpack nt,dtint = S_kf.grid
        @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S_kf.grid
    
        # calculate layer thicknesses for initial conditions
        ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S_kf.forcing.H)
        ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
        ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
        ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)
    
        # calculate PV terms for initial conditions
        urhs = S_kf.Diag.PrognosticVarsRHS.u .= S_kf.Prog.u
        vrhs = S_kf.Diag.PrognosticVarsRHS.v .= S_kf.Prog.v
        ηrhs = S_kf.Diag.PrognosticVarsRHS.η .= S_kf.Prog.η
    
        ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S_kf)
        ShallowWaters.PVadvection!(Diag,S_kf)
    
        # propagate initial conditions
        copyto!(u0,u)
        copyto!(v0,v)
        copyto!(η0,η)
    
        # store initial conditions of sst for relaxation
        copyto!(Diag.SemiLagrange.sst_ref,sst)

        push!(S_all, S_kf)

    end

    for t = 1:S_for_values.grid.nt

        Progkf = []

        for n = 1:N

            p = one_step_function(S_all[n])
            push!(Progkf, p)

        end

        if t ∈ S_for_values.parameters.data_steps

            for k = 1:N

                Z[1:(nu+nv+nT), k] = [vec(Progkf[k].u); vec(Progkf[k].v); vec(Progkf[k].η)]
                Z[end,k] = S_all[k].parameters.Fx0
                U[:, k] = Z[Int.(data_spots), k]

            end

            d = data[:, S_for_values.parameters.j]
            E = (sigma_data .* randn(size(data[:,1])[1], N)) ./ sqrt(N-1)
            D = d * ones(N)' + sqrt(N - 1) .* E
            E = D * Π
            A = Z * Π
            Y = U * Π

            D̃ = D - U
            temp = Y*Y' + E*E'
            tempinv = (temp' * temp) * temp'
            W = Y'*(tempinv)*D̃

            Z = Z + A*W ./ (sqrt(N - 1))

            for k = 1:N

                Progkf[k].u .= reshape(Z[1:nu,k],S_for_values.grid.nux,S_for_values.grid.nuy)
                Progkf[k].v .= reshape(Z[nu+1:nv+nu,k],S_for_values.grid.nvx,S_for_values.grid.nvy)
                Progkf[k].η .= reshape(Z[nv+nu+1:nu+nv+nT,k],S_for_values.grid.nx,S_for_values.grid.ny)

                u,v,eta = ShallowWaters.add_halo(Progkf[k].u,
                    Progkf[k].v,
                    Progkf[k].η,
                    Progkf[k].sst,
                    S_all[k]
                )

                S_all[k].Prog.u = u
                S_all[k].Prog.v = v
                S_all[k].Prog.η = eta
                S_all[k].parameters.Fx0 = Z[end,k]

            end

            S_for_values.parameters.j += 1

        end

        if t ∈ 10:10:S_for_values.grid.nt

            kf_avgu = zeros(127,128)
            kf_avgv = zeros(128,127)
            for n = 1:N
                kf_avgu = kf_avgu .+ Progkf[n].u
                kf_avgv = kf_avgv .+ Progkf[n].v
            end

            push!(ekf_avgu, (kf_avgu)./N)
            push!(ekf_avgv, (kf_avgv)./N)

        end

    end

    return S_all, ekf_avgu, ekf_avgv

end

"""
This function will create N (the number of ensembles) Bred vectors, which
will get used as the initial perturbations for the EKF
"""
function compute_bred_vectors(N, sigma_initcond, uic_nohalo, vic_nohalo, etaic_nohalo, parameters)

    utrue = ncread("./data_files/128_postspinup_30days_hourlysaves/u.nc", "u")[:,:,1];
    etatrue = ncread("./data_files/128_postspinup_30days_hourlysaves/eta.nc", "eta")[:,:,1];

    sigma_bvu = ( (sum(abs.(utrue .- uic_nohalo)) / (128*127)) )/ 100
    sigma_bveta = ( (sum(abs.(etatrue .- etaic_nohalo)) / (128^2)) )/ 100

    println("sigma_bvu: ", sigma_bvu)
    println("sigma_bveta: ", sigma_bveta)

    bred_vectors = []

    for n = 1:N

        P = parameters
        S1 = ShallowWaters.model_setup(P)
        S2 = ShallowWaters.model_setup(P)

        S1.parameters.Ndays = 1
        S2.parameters.Ndays = 1

        upred,vpred,etapred,_ = ShallowWaters.add_halo(uic_nohalo,vic_nohalo,etaic_nohalo,zeros(128,128),S1)

        # S1 will iterate the original unperturbed solution
        S1.Prog.u = copy(upred)
        S1.Prog.v = copy(vpred)
        S1.Prog.η = copy(etapred)

        # S2 will iterate the perturbed solutions
        S2.Prog.u = copy(upred)
        S2.Prog.v = copy(vpred)
        S2.Prog.η = copy(etapred)

        Prog = ShallowWaters.PrognosticVars{Float64}(ShallowWaters.remove_halo(S2.Prog.u,
            S2.Prog.v,
            S2.Prog.η,
            S2.Prog.sst,
            S2)...
        )

        # perturb initial conditions from the guessed value for each ensemble member
        upert = sigma_bvu .* randn(size(Prog.u))
        vpert = sigma_bvu .* randn(size(Prog.v))
        etapert = sigma_bveta .* randn(size(Prog.η))

        # computing norms of the initial perturbations
        Au = norm(upert)
        Av = norm(vpert)
        Aeta = norm(etapert)

        # apply the perturbation to the initial condition
        Prog.u = Prog.u + upert
        Prog.v = Prog.v + vpert
        Prog.η = Prog.η + etapert

        uperturbed,vperturbed,etaperturbed,_ = ShallowWaters.add_halo(Prog.u,Prog.v,Prog.η,zeros(128,128),S2)

        # store this in S2
        S2.Prog.u = uperturbed
        S2.Prog.v = vperturbed
        S2.Prog.η = etaperturbed

        # Store the two initial models to be integrated
        S_all = []
        push!(S_all, S1)
        push!(S_all, S2)

        # code that appears before the time integration
        for S in S_all

            Diag = S.Diag
            Prog = S.Prog
        
            @unpack u,v,η,sst = Prog
            @unpack u0,v0,η0 = Diag.RungeKutta
            @unpack u1,v1,η1 = Diag.RungeKutta
            @unpack du,dv,dη = Diag.Tendencies
            @unpack du_sum,dv_sum,dη_sum = Diag.Tendencies
            @unpack du_comp,dv_comp,dη_comp = Diag.Tendencies
        
            @unpack um,vm = Diag.SemiLagrange
        
            @unpack dynamics,RKo,RKs,tracer_advection = S.parameters
            @unpack time_scheme,compensated = S.parameters
            @unpack RKaΔt,RKbΔt = S.constants
            @unpack Δt_Δ,Δt_Δs = S.constants
        
            @unpack nt,dtint = S.grid
            @unpack nstep_advcor,nstep_diff,nadvstep,nadvstep_half = S.grid
        
            # calculate layer thicknesses for initial conditions
            ShallowWaters.thickness!(Diag.VolumeFluxes.h,η,S.forcing.H)
            ShallowWaters.Ix!(Diag.VolumeFluxes.h_u,Diag.VolumeFluxes.h)
            ShallowWaters.Iy!(Diag.VolumeFluxes.h_v,Diag.VolumeFluxes.h)
            ShallowWaters.Ixy!(Diag.Vorticity.h_q,Diag.VolumeFluxes.h)

            # calculate PV terms for initial conditions
            urhs = S.Diag.PrognosticVarsRHS.u .= S.Prog.u
            vrhs = S.Diag.PrognosticVarsRHS.v .= S.Prog.v
            ηrhs = S.Diag.PrognosticVarsRHS.η .= S.Prog.η
        
            ShallowWaters.advection_coriolis!(urhs,vrhs,ηrhs,Diag,S)
            ShallowWaters.PVadvection!(Diag,S)
        
            # propagate initial conditions
            copyto!(u0,u)
            copyto!(v0,v)
            copyto!(η0,η)
        
            # store initial conditions of sst for relaxation
            copyto!(Diag.SemiLagrange.sst_ref,sst)
        end

        # I need to change this to be (1) do the following for one day, get the new perturbation, perturb, and then restart the day
        for i = 1:20

            if i === 20

                S_all[1].parameters.Ndays=1
                S_all[2].parameters.Ndays=1

                p1 = ShallowWaters.time_integration(deepcopy(S_all[1]));
                p2 = ShallowWaters.time_integration(deepcopy(S_all[2]));

                normu = norm(p1.u - p2.u)
                normv = norm(p1.v - p2.v)
                normeta = norm(p1.η - p2.η)

                uperturbation = (p1.u - p2.u) * (Au / normu)
                vperturbation = (p1.v - p2.v) * (Av / normv)
                etaperturbation = (p1.η - p2.η) * (Aeta / normeta)

                push!(bred_vectors, [vec(uperturbation); vec(vperturbation); vec(etaperturbation)])

                println("Norm of first bred vector minus the latest: ", norm(bred_vectors[1] .- [vec(uperturbation); vec(vperturbation); vec(etaperturbation)]))
                println("Norm of current bred vector: ", norm([vec(uperturbation); vec(vperturbation); vec(etaperturbation)]))


            end

            S_all[1].parameters.Ndays=1
            S_all[2].parameters.Ndays=1

            p1 = ShallowWaters.time_integration(deepcopy(S_all[1]));
            p2 = ShallowWaters.time_integration(deepcopy(S_all[2]));

            normu = norm(p2.u)
            normv = norm(p2.v)
            normeta = norm(p2.η)

            uperturbation = (p1.u - p2.u) * (Au / normu)
            vperturbation = (p1.v - p2.v) * (Av / normv)
            etaperturbation = (p1.η - p2.η) * (Aeta / normeta)

            Prog1 = ShallowWaters.PrognosticVars{Float64}(ShallowWaters.remove_halo(S_all[1].Prog.u,
                S_all[1].Prog.v,
                S_all[1].Prog.η,
                S_all[1].Prog.sst,
                S_all[1])...
            )
            Prog1.u .= uic_nohalo
            Prog1.v .= vic_nohalo
            Prog1.η .= etaic_nohalo

            Prog2 = ShallowWaters.PrognosticVars{Float64}(ShallowWaters.remove_halo(S_all[2].Prog.u,
                S_all[2].Prog.v,
                S_all[2].Prog.η,
                S_all[2].Prog.sst,
                S_all[2])...
            )

            Prog2.u = copy(Prog1.u) + uperturbation
            Prog2.v = copy(Prog1.v) + vperturbation
            Prog2.η = copy(Prog1.η) + etaperturbation

            uic,vic,etaic,_ = ShallowWaters.add_halo(Prog2.u,Prog2.v,Prog2.η,Prog2.sst,S_all[2])

            S_all[2].Prog.u = uic
            S_all[2].Prog.v = vic
            S_all[2].Prog.η = etaic

            # upred,vpred,etapred,_ = ShallowWaters.add_halo(Prog1.u,Prog1.v,Prog1.η,zeros(128,128),S_all[1])

            # # S1 will iterate the original unperturbed solution
            # S1.Prog.u = copy(upred)
            # S1.Prog.v = copy(vpred)
            # S1.Prog.η = copy(etapred)

        end

    end

    return bred_vectors

end